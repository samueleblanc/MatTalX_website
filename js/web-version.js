/*
    The main purpose of this program is to take a text as input (mostly LaTeX commands), 
    to convert them into the desired symbol (character) and finally to display them so they can 
    be copied and sent via Messenger, Instagram, Twitter, etc.
*/


/*
    CODE STRUCTURE
    
    N.B. Every section header has the format: /// NAME /// and every subsection: * Name *


    /// GLOBALS ///  -> All the global variables
    â”‚
    â”œâ”€ Functions (as const)
    â”œâ”€ Dictionaries
    â”œâ”€ HTMLElements
    â”œâ”€ Other
    â”‚
    /// FUNCTIONS ///  -> All the functions
    â”‚
    â”œâ”€ Front-end
    â”œâ”€ Completion box
    â”œâ”€ Convert text
    â”‚   â”œâ”€ Main functions
    â”‚   â””â”€ Used by main functions
    â”œâ”€ Check mistakes
    â”œâ”€ Matrix function
    â”œâ”€ Automatic spacing
    â””â”€ Main
*/


/**************************************************************************************/

"use strict";

/// GLOBALS ///


/** Functions (as const) **/

const mathbb = (arg, initialCommand) => {
    // mathbb stands for math blackboard-bold
    // This function converts the list of characters to the corresponding blackboard-bold character
    const symbols = {
        "A" : "\u{1D538}",
        "B" : "\u{1D539}",
        "C" : "\u2102",
        "D" : "\u{1D53B}",
        "E" : "\u{1D53C}",
        "F" : "\u{1D53D}",
        "G" : "\u{1D53E}",
        "H" : "\u210D",
        "I" : "\u{1D540}",
        "J" : "\u{1D541}",
        "K" : "\u{1D542}",
        "L" : "\u{1D543}",
        "M" : "\u{1D544}",
        "N" : "\u2115",
        "O" : "\u{1D546}",
        "P" : "\u2119",
        "Q" : "\u211A",
        "R" : "\u211D",
        "S" : "\u{1D54A}",
        "T" : "\u{1D54B}",
        "U" : "\u{1D54C}",
        "V" : "\u{1D54D}",
        "W" : "\u{1D54E}",
        "X" : "\u{1D54F}",
        "Y" : "\u{1D550}",
        "Z" : "\u2124",
        "a" : "\u{1D552}",
        "b" : "\u{1D553}",
        "c" : "\u{1D554}",
        "d" : "\u{1D555}",
        "e" : "\u{1D556}",
        "f" : "\u{1D557}",
        "g" : "\u{1D558}",
        "h" : "\u{1D559}",
        "i" : "\u{1D55A}",
        "j" : "\u{1D55B}",
        "k" : "\u{1D55C}",
        "l" : "\u{1D55D}",
        "m" : "\u{1D55E}",
        "n" : "\u{1D55F}",
        "o" : "\u{1D560}",
        "p" : "\u{1D561}",
        "q" : "\u{1D562}",
        "r" : "\u{1D563}",
        "s" : "\u{1D564}",
        "t" : "\u{1D565}",
        "u" : "\u{1D566}",
        "v" : "\u{1D567}",
        "w" : "\u{1D568}",
        "x" : "\u{1D569}",
        "y" : "\u{1D56A}",
        "z" : "\u{1D56B}",

        "ğ´" : "\u{1D538}",
        "ğµ" : "\u{1D539}",
        "ğ¶" : "\u2102",
        "ğ·" : "\u{1D53B}",
        "ğ¸" : "\u{1D53C}",
        "ğ¹" : "\u{1D53D}",
        "ğº" : "\u{1D53E}",
        "ğ»" : "\u210D",
        "ğ¼" : "\u{1D540}",
        "ğ½" : "\u{1D541}",
        "ğ¾" : "\u{1D542}",
        "ğ¿" : "\u{1D543}",
        "ğ‘€" : "\u{1D544}",
        "ğ‘" : "\u2115",
        "ğ‘‚" : "\u{1D546}",
        "ğ‘ƒ" : "\u2119",
        "ğ‘„" : "\u211A",
        "ğ‘…" : "\u211D",
        "ğ‘†" : "\u{1D54A}",
        "ğ‘‡" : "\u{1D54B}",
        "ğ‘ˆ" : "\u{1D54C}",
        "ğ‘‰" : "\u{1D54D}",
        "ğ‘Š" : "\u{1D54E}",
        "ğ‘‹" : "\u{1D54F}",
        "ğ‘Œ" : "\u{1D550}",
        "ğ‘" : "\u2124",
        "ğ‘" : "\u{1D552}",
        "ğ‘" : "\u{1D553}",
        "ğ‘" : "\u{1D554}",
        "ğ‘‘" : "\u{1D555}",
        "ğ‘’" : "\u{1D556}",
        "ğ‘“" : "\u{1D557}",
        "ğ‘”" : "\u{1D558}",
        "â„" : "\u{1D559}",
        "ğ‘–" : "\u{1D55A}",
        "ğ‘—" : "\u{1D55B}",
        "ğ‘˜" : "\u{1D55C}",
        "ğ‘™" : "\u{1D55D}",
        "ğ‘š" : "\u{1D55E}",
        "ğ‘›" : "\u{1D55F}",
        "ğ‘œ" : "\u{1D560}",
        "ğ‘" : "\u{1D561}",
        "ğ‘" : "\u{1D562}",
        "ğ‘Ÿ" : "\u{1D563}",
        "ğ‘ " : "\u{1D564}",
        "ğ‘¡" : "\u{1D565}",
        "ğ‘¢" : "\u{1D566}",
        "ğ‘£" : "\u{1D567}",
        "ğ‘¤" : "\u{1D568}",
        "ğ‘¥" : "\u{1D569}",
        "ğ‘¦" : "\u{1D56A}",
        "ğ‘§" : "\u{1D56B}",
        
        "ğ›¾" : "\u213D",
        "ğ›¤" : "\u213E",
        "ğ›±" : "\u213F",
        "ğœ‹" : "\u213C",
        "ğ›´" : "\u2140",
        "Î£" : "\u2140",
        "Î " : "\u213F",
        "Ï€" : "\u213C",
        "Î³" : "\u213D",
        "Î“" : "\u213E",

        "0" : "\u{1D7D8}",
        "1" : "\u{1D7D9}",
        "2" : "\u{1D7DA}",
        "3" : "\u{1D7DB}",
        "4" : "\u{1D7DC}",
        "5" : "\u{1D7DD}",
        "6" : "\u{1D7DE}",
        "7" : "\u{1D7DF}",
        "8" : "\u{1D7E0}",
        "9" : "\u{1D7E1}",

        "(" : "â¦…",
        "{" : "â¦ƒ",
        "[" : "âŸ¦",
        "]" : "âŸ§",
        "}" : "â¦„",
        ")" : "â¦†",

        // Spaces (\:, \;, \quad and \qquad are passed as a single character in mistakes) 
        "\u2710" : spacesChar.add,
        "\u2710\u2710" : spacesChar.add+spacesChar.add,
        "\u2710\u2710\u2710" : spacesChar.add+spacesChar.add+spacesChar.add,
        "\u2710\u2710\u2710\u2710" : spacesChar.add+spacesChar.add+spacesChar.add+spacesChar.add,
        "\u270E" : spacesChar.remove,
        " " : " ",
        "\u000A" : "\u000A",
        "" : ""
    };
    return replaceLetters(arg[0], symbols, initialCommand).concat(extraArgs(arg.slice(1), initialCommand));
};

const mathbf = (arg, initialCommand) => {
    // mathbf stands for math bold font
    // This function converts the list of characters to the corresponding bold font character
    const symbols = {
        "A" : "\u{1D468}",
        "a" : "\u{1D482}",
        "B" : "\u{1D469}",
        "b" : "\u{1D483}",
        "C" : "\u{1D46A}",
        "c" : "\u{1D484}",
        "D" : "\u{1D46B}",
        "d" : "\u{1D485}",
        "E" : "\u{1D46C}",
        "e" : "\u{1D486}",
        "F" : "\u{1D46D}",
        "f" : "\u{1D487}",
        "G" : "\u{1D46E}",
        "g" : "\u{1D488}",
        "H" : "\u{1D46F}",
        "h" : "\u{1D489}",
        "I" : "\u{1D470}",
        "i" : "\u{1D48A}",
        "J" : "\u{1D471}",
        "j" : "\u{1D48B}",
        "K" : "\u{1D472}",
        "k" : "\u{1D48C}",
        "L" : "\u{1D473}",
        "l" : "\u{1D48D}",
        "M" : "\u{1D474}",
        "m" : "\u{1D48E}",
        "N" : "\u{1D475}",
        "n" : "\u{1D48F}",
        "O" : "\u{1D476}",
        "o" : "\u{1D490}",
        "P" : "\u{1D477}",
        "p" : "\u{1D491}",
        "Q" : "\u{1D478}",
        "q" : "\u{1D492}",
        "R" : "\u{1D479}",
        "r" : "\u{1D493}",
        "S" : "\u{1D47A}",
        "s" : "\u{1D494}",
        "T" : "\u{1D47B}",
        "t" : "\u{1D495}",
        "U" : "\u{1D47C}",
        "u" : "\u{1D496}",
        "V" : "\u{1D47D}",
        "v" : "\u{1D497}",
        "W" : "\u{1D47E}",
        "w" : "\u{1D498}",
        "X" : "\u{1D47F}",
        "x" : "\u{1D499}",
        "Y" : "\u{1D480}",
        "y" : "\u{1D49A}",
        "Z" : "\u{1D481}",
        "z" : "\u{1D49B}",

        "ğ´" : "\u{1D468}",
        "ğ‘" : "\u{1D482}",
        "ğµ" : "\u{1D469}",
        "ğ‘" : "\u{1D483}",
        "ğ¶" : "\u{1D46A}",
        "ğ‘" : "\u{1D484}",
        "ğ·" : "\u{1D46B}",
        "ğ‘‘" : "\u{1D485}",
        "ğ¸" : "\u{1D46C}",
        "ğ‘’" : "\u{1D486}",
        "ğ¹" : "\u{1D46D}",
        "ğ‘“" : "\u{1D487}",
        "ğº" : "\u{1D46E}",
        "ğ‘”" : "\u{1D488}",
        "ğ»" : "\u{1D46F}",
        "â„" : "\u{1D489}",
        "ğ¼" : "\u{1D470}",
        "ğ‘–" : "\u{1D48A}",
        "ğ½" : "\u{1D471}",
        "ğ‘—" : "\u{1D48B}",
        "ğ¾" : "\u{1D472}",
        "ğ‘˜" : "\u{1D48C}",
        "ğ¿" : "\u{1D473}",
        "ğ‘™" : "\u{1D48D}",
        "ğ‘€" : "\u{1D474}",
        "ğ‘š" : "\u{1D48E}",
        "ğ‘" : "\u{1D475}",
        "ğ‘›" : "\u{1D48F}",
        "ğ‘‚" : "\u{1D476}",
        "ğ‘œ" : "\u{1D490}",
        "ğ‘ƒ" : "\u{1D477}",
        "ğ‘" : "\u{1D491}",
        "ğ‘„" : "\u{1D478}",
        "ğ‘" : "\u{1D492}",
        "ğ‘…" : "\u{1D479}",
        "ğ‘Ÿ" : "\u{1D493}",
        "ğ‘†" : "\u{1D47A}",
        "ğ‘ " : "\u{1D494}",
        "ğ‘‡" : "\u{1D47B}",
        "ğ‘¡" : "\u{1D495}",
        "ğ‘ˆ" : "\u{1D47C}",
        "ğ‘¢" : "\u{1D496}",
        "ğ‘‰" : "\u{1D47D}",
        "ğ‘£" : "\u{1D497}",
        "ğ‘Š" : "\u{1D47E}",
        "ğ‘¤" : "\u{1D498}",
        "ğ‘‹" : "\u{1D47F}",
        "ğ‘¥" : "\u{1D499}",
        "ğ‘Œ" : "\u{1D480}",
        "ğ‘¦" : "\u{1D49A}",
        "ğ‘" : "\u{1D481}",
        "ğ‘§" : "\u{1D49B}",

        "0" : "\u{1D7CE}",
        "1" : "\u{1D7CF}",
        "2" : "\u{1D7D0}",
        "3" : "\u{1D7D1}",
        "4" : "\u{1D7D2}",
        "5" : "\u{1D7D3}",
        "6" : "\u{1D7D4}",
        "7" : "\u{1D7D5}",
        "8" : "\u{1D7D6}",
        "9" : "\u{1D7D7}",

        "âˆ‚" : "\u{1D789}",

        // Greek
        "ğ›¢" : "\u{1D71C}",
        "ğ›¼" : "\u{1D736}",
        "ğ›£" : "\u{1D71D}",
        "ğ›½" : "\u{1D737}",
        "ğ›¤" : "\u{1D71E}",
        "ğ›¾" : "\u{1D738}",
        "Î”" : "\u{1D6AB}",
        "ğ›¥" : "\u{1D71F}",
        "ğ›¿" : "\u{1D739}",
        "ğ›¦" : "\u{1D720}",
        "Ïµ" : "\u{1D6DC}",
        "Îµ" : "\u{1D6C6}",
        "ğ›§" : "\u{1D721}",
        "ğœ" : "\u{1D73B}",
        "ğ›¨" : "\u{1D722}",
        "ğœ‚" : "\u{1D73C}",
        "Î˜" : "\u{1D6BD}",
        "ğœƒ" : "\u{1D73D}",
        "ğœ—" : "\u{1D751}",
        "ğ›ª" : "\u{1D724}",
        "ğœ„" : "\u{1D73E}",
        "ğ›«" : "\u{1D725}",
        "ğœ…" : "\u{1D73F}",
        "ğœ˜" : "\u{1D752}",
        "ğ›¬" : "\u{1D726}",
        "ğœ†" : "\u{1D740}",
        "ğ›­" : "\u{1D727}",
        "ğœ‡" : "\u{1D741}",
        "ğ›®" : "\u{1D728}",
        "ğœˆ" : "\u{1D742}",
        "Î" : "\u{1D6B5}",
        "ğœ‰" : "\u{1D743}",
        "ğ›°" : "\u{1D72A}",
        "ğœŠ" : "\u{1D744}",
        "ğ›±" : "\u{1D72B}",
        "ğœ‹" : "\u{1D745}",
        "ğœ›" : "\u{1D755}",
        "ğ›²" : "\u{1D72C}",
        "ğœŒ" : "\u{1D746}",
        "ğœš" : "\u{1D754}",
        "ğ›´" : "\u{1D72E}",
        "ğœ" : "\u{1D748}",
        "ğœ" : "\u{1D747}",
        "ğ›µ" : "\u{1D72F}",
        "ğœ" : "\u{1D749}",
        "ğ›¶" : "\u{1D730}",
        "ğœ" : "\u{1D74A}",
        "Î¦" : "\u{1D6BD}",
        "ğœ™" : "\u{1D753}",
        "ğœ‘" : "\u{1D74B}",
        "ğ›¸" : "\u{1D732}",
        "ğœ’" : "\u{1D74C}",
        "ğ›¹" : "\u{1D733}",
        "ğœ“" : "\u{1D74D}",
        "â„¦" : "\u{1D6C0}",
        "ğœ”" : "\u{1D74E}",

        "Î‘" : "\u{1D756}",
        "Î±" : "\u{1D770}",
        "Î’" : "\u{1D757}",
        "Î²" : "\u{1D771}",
        "Î“" : "\u{1D758}",
        "Î³" : "\u{1D772}",
        "Î´" : "\u{1D6C5}",
        "Î•" : "\u{1D75A}",
        "Î–" : "\u{1D75B}",
        "Î¶" : "\u{1D775}",
        "Î—" : "\u{1D75C}",
        "Î·" : "\u{1D776}",
        "Î¸" : "\u{1D6C9}",
        "Ï‘" : "\u{1D6DD}",
        "Î™" : "\u{1D75E}",
        "Î¹" : "\u{1D6CA}",
        "Îš" : "\u{1D75F}",
        "Îº" : "\u{1D779}",
        "Ï°" : "\u{1D78C}",
        "Î›" : "\u{1D760}",
        "Î»" : "\u{1D77A}",
        "Îœ" : "\u{1D761}",
        "Î¼" : "\u{1D77B}",
        "Î" : "\u{1D762}",
        "Î½" : "\u{1D77C}",
        "Î¾" : "\u{1D77D}",
        "ÎŸ" : "\u{1D764}",
        "Î¿" : "\u{1D77E}",
        "Î " : "\u{1D765}",
        "Ï€" : "\u{1D77F}",
        "Ï–" : "\u{1D78F}",
        "Î¡" : "\u{1D766}",
        "Ï" : "\u{1D780}",
        "Ï±" : "\u{1D78E}",
        "Î£" : "\u{1D768}",
        "Ïƒ" : "\u{1D782}",
        "Ï‚" : "\u{1D781}",
        "Î¤" : "\u{1D769}",
        "Ï„" : "\u{1D783}",
        "Î¥" : "\u{1D76A}",
        "Ï…" : "\u{1D784}",
        "Ï•" : "\u{1D78D}",
        "Ï†" : "\u{1D785}",
        "Î§" : "\u{1D76C}",
        "Ï‡" : "\u{1D786}",
        "Î¨" : "\u{1D76D}",
        "Ïˆ" : "\u{1D787}",
        "Î©" : "\u{1D76E}",
        "Ï‰" : "\u{1D788}",

        // mathcal
        "ğ’œ" : "\u{1D4D0}",
        "ğ’¶" : "\u{1D4EA}",
        "â„¬" : "\u{1D4D1}",
        "ğ’·" : "\u{1D4EB}",
        "ğ’" : "\u{1D4D2}",
        "ğ’¸" : "\u{1D4EC}",
        "ğ’Ÿ" : "\u{1D4D3}",
        "ğ’¹" : "\u{1D4ED}",
        "â„°" : "\u{1D4D4}",
        "â„¯" : "\u{1D4EE}",
        "â„±" : "\u{1D4D5}",
        "ğ’»" : "\u{1D4EF}",
        "ğ’¢" : "\u{1D4D6}",
        "â„Š" : "\u{1D4F0}",
        "â„‹" : "\u{1D4D7}",
        "ğ’½" : "\u{1D4F1}",
        "â„" : "\u{1D4D8}",
        "ğ’¾" : "\u{1D4F2}",
        "ğ’¥" : "\u{1D4D9}",
        "ğ’¿" : "\u{1D4F3}",
        "ğ’¦" : "\u{1D4DA}",
        "ğ“€" : "\u{1D4F4}",
        "â„’" : "\u{1D4DB}",
        "ğ“" : "\u{1D4F5}",
        "â„³" : "\u{1D4DC}",
        "ğ“‚" : "\u{1D4F6}",
        "ğ’©" : "\u{1D4DD}",
        "ğ“ƒ" : "\u{1D4F7}",
        "ğ’ª" : "\u{1D4DE}",
        "â„´" : "\u{1D4F8}",
        "ğ’«" : "\u{1D4DF}",
        "ğ“…" : "\u{1D4F9}",
        "ğ’¬" : "\u{1D4E0}",
        "ğ“†" : "\u{1D4FA}",
        "â„›" : "\u{1D4E1}",
        "ğ“‡" : "\u{1D4FB}",
        "ğ’®" : "\u{1D4E2}",
        "ğ“ˆ" : "\u{1D4FC}",
        "ğ’¯" : "\u{1D4E3}",
        "ğ“‰" : "\u{1D4FD}",
        "ğ’°" : "\u{1D4E4}",
        "ğ“Š" : "\u{1D4FE}",
        "ğ’±" : "\u{1D4E5}",
        "ğ“‹" : "\u{1D4FF}",
        "ğ’²" : "\u{1D4E6}",
        "ğ“Œ" : "\u{1D500}",
        "ğ’³" : "\u{1D4E7}",
        "ğ“" : "\u{1D501}",
        "ğ’´" : "\u{1D4E8}",
        "ğ“" : "\u{1D502}",
        "ğ’µ" : "\u{1D4E9}",
        "ğ“" : "\u{1D503}",

        // mathfrak
        "ğ”„" : "\u{1D56C}",
        "ğ”" : "\u{1D586}",
        "ğ”…" : "\u{1D56D}",
        "ğ”Ÿ" : "\u{1D587}",
        "â„­" : "\u{1D56E}",
        "ğ” " : "\u{1D588}",
        "ğ”‡" : "\u{1D56F}",
        "ğ”¡" : "\u{1D589}",
        "ğ”ˆ" : "\u{1D570}",
        "ğ”¢" : "\u{1D58A}",
        "ğ”‰" : "\u{1D571}",
        "ğ”£" : "\u{1D58B}",
        "ğ”Š" : "\u{1D572}",
        "ğ”¤" : "\u{1D58C}",
        "â„Œ" : "\u{1D573}",
        "ğ”¥" : "\u{1D58D}",
        "â„‘" : "\u{1D574}",
        "ğ”¦" : "\u{1D58E}",
        "ğ”" : "\u{1D575}",
        "ğ”§" : "\u{1D58F}",
        "ğ”" : "\u{1D576}",
        "ğ”¨" : "\u{1D590}",
        "ğ”" : "\u{1D577}",
        "ğ”©" : "\u{1D591}",
        "ğ”" : "\u{1D578}",
        "ğ”ª" : "\u{1D592}",
        "ğ”‘" : "\u{1D579}",
        "ğ”«" : "\u{1D593}",
        "ğ”’" : "\u{1D57A}",
        "ğ”¬" : "\u{1D594}",
        "ğ”“" : "\u{1D57B}",
        "ğ”­" : "\u{1D595}",
        "ğ””" : "\u{1D57C}",
        "ğ”®" : "\u{1D596}",
        "â„œ" : "\u{1D57D}",
        "ğ”¯" : "\u{1D597}",
        "ğ”–" : "\u{1D57E}",
        "ğ”°" : "\u{1D598}",
        "ğ”—" : "\u{1D57F}",
        "ğ”±" : "\u{1D599}",
        "ğ”˜" : "\u{1D580}",
        "ğ”²" : "\u{1D59A}",
        "ğ”™" : "\u{1D581}",
        "ğ”³" : "\u{1D59B}",
        "ğ”š" : "\u{1D582}",
        "ğ”´" : "\u{1D59C}",
        "ğ”›" : "\u{1D583}",
        "ğ”µ" : "\u{1D59D}",
        "ğ”œ" : "\u{1D584}",
        "ğ”¶" : "\u{1D59E}",
        "â„¨" : "\u{1D585}",
        "ğ”·" : "\u{1D59F}",

        // Spaces (\:, \;, \quad and \qquad are passed as a single character in mistakes) 
        "\u2710" : spacesChar.add,
        "\u2710\u2710" : spacesChar.add+spacesChar.add,
        "\u2710\u2710\u2710" : spacesChar.add+spacesChar.add+spacesChar.add,
        "\u2710\u2710\u2710\u2710" : spacesChar.add+spacesChar.add+spacesChar.add+spacesChar.add,
        "\u270E" : spacesChar.remove,
        " " : " ",
        "\u000A" : "\u000A",
        "" : ""
    };
    return replaceLetters(arg[0], symbols, initialCommand).concat(extraArgs(arg.slice(1), initialCommand));
};

const mathcal = (arg, initialCommand) => {
    // mathcal stands for math calligraphic
    // This function converts the list of characters to the corresponding calligraphic character
    const symbols = {
        "A" : "\u{1D49C}",
        "a" : "\u{1D4B6}",
        "B" : "\u212C",
        "b" : "\u{1D4B7}",
        "C" : "\u{1D49E}",
        "c" : "\u{1D4B8}",
        "D" : "\u{1D49F}",
        "d" : "\u{1D4B9}",
        "E" : "\u2130",
        "e" : "\u212F",
        "F" : "\u2131",
        "f" : "\u{1D4BB}",
        "G" : "\u{1D4A2}",
        "g" : "\u210A",
        "H" : "\u210B",
        "h" : "\u{1D4BD}",
        "I" : "\u2110",
        "i" : "\u{1D4BE}",
        "J" : "\u{1D4A5}",
        "j" : "\u{1D4BF}",
        "K" : "\u{1D4A6}",
        "k" : "\u{1D4C0}",
        "L" : "\u2112",
        "l" : "\u{1D4C1}",
        "M" : "\u2133",
        "m" : "\u{1D4C2}",
        "N" : "\u{1D4A9}",
        "n" : "\u{1D4C3}",
        "O" : "\u{1D4AA}",
        "o" : "\u2134",
        "P" : "\u{1D4AB}",
        "p" : "\u{1D4C5}",
        "Q" : "\u{1D4AC}",
        "q" : "\u{1D4C6}",
        "R" : "\u211B",
        "r" : "\u{1D4C7}",
        "S" : "\u{1D4AE}",
        "s" : "\u{1D4C8}",
        "T" : "\u{1D4AF}",
        "t" : "\u{1D4C9}",
        "U" : "\u{1D4B0}",
        "u" : "\u{1D4CA}",
        "V" : "\u{1D4B1}",
        "v" : "\u{1D4CB}",
        "W" : "\u{1D4B2}",
        "w" : "\u{1D4CC}",
        "X" : "\u{1D4B3}",
        "x" : "\u{1D4CD}",
        "Y" : "\u{1D4B4}",
        "y" : "\u{1D4CE}",
        "Z" : "\u{1D4B5}",
        "z" : "\u{1D4CF}",

        "ğ´" : "\u{1D49C}",
        "ğ‘" : "\u{1D4B6}",
        "ğµ" : "\u212C",
        "ğ‘" : "\u{1D4B7}",
        "ğ¶" : "\u{1D49E}",
        "ğ‘" : "\u{1D4B8}",
        "ğ·" : "\u{1D49F}",
        "ğ‘‘" : "\u{1D4B9}",
        "ğ¸" : "\u2130",
        "ğ‘’" : "\u212F",
        "ğ¹" : "\u2131",
        "ğ‘“" : "\u{1D4BB}",
        "ğº" : "\u{1D4A2}",
        "ğ‘”" : "\u210A",
        "ğ»" : "\u210B",
        "â„" : "\u{1D4BD}",
        "ğ¼" : "\u2110",
        "ğ‘–" : "\u{1D4BE}",
        "ğ½" : "\u{1D4A5}",
        "ğ‘—" : "\u{1D4BF}",
        "ğ¾" : "\u{1D4A6}",
        "ğ‘˜" : "\u{1D4C0}",
        "ğ¿" : "\u2112",
        "ğ‘™" : "\u{1D4C1}",
        "ğ‘€" : "\u2133",
        "ğ‘š" : "\u{1D4C2}",
        "ğ‘" : "\u{1D4A9}",
        "ğ‘›" : "\u{1D4C3}",
        "ğ‘‚" : "\u{1D4AA}",
        "ğ‘œ" : "\u2134",
        "ğ‘ƒ" : "\u{1D4AB}",
        "ğ‘" : "\u{1D4C5}",
        "ğ‘„" : "\u{1D4AC}",
        "ğ‘" : "\u{1D4C6}",
        "ğ‘…" : "\u211B",
        "ğ‘Ÿ" : "\u{1D4C7}",
        "ğ‘†" : "\u{1D4AE}",
        "ğ‘ " : "\u{1D4C8}",
        "ğ‘‡" : "\u{1D4AF}",
        "ğ‘¡" : "\u{1D4C9}",
        "ğ‘ˆ" : "\u{1D4B0}",
        "ğ‘¢" : "\u{1D4CA}",
        "ğ‘‰" : "\u{1D4B1}",
        "ğ‘£" : "\u{1D4CB}",
        "ğ‘Š" : "\u{1D4B2}",
        "ğ‘¤" : "\u{1D4CC}",
        "ğ‘‹" : "\u{1D4B3}",
        "ğ‘¥" : "\u{1D4CD}",
        "ğ‘Œ" : "\u{1D4B4}",
        "ğ‘¦" : "\u{1D4CE}",
        "ğ‘" : "\u{1D4B5}",
        "ğ‘§" : "\u{1D4CF}",

        "ğ‘¨" : "\u{1D4D0}",
        "ğ’‚" : "\u{1D4EA}",
        "ğ‘©" : "\u{1D4D1}",
        "ğ’ƒ" : "\u{1D4EB}",
        "ğ‘ª" : "\u{1D4D2}",
        "ğ’„" : "\u{1D4EC}",
        "ğ‘«" : "\u{1D4D3}",
        "ğ’…" : "\u{1D4ED}",
        "ğ‘¬" : "\u{1D4D4}",
        "ğ’†" : "\u{1D4EE}",
        "ğ‘­" : "\u{1D4D5}",
        "ğ’‡" : "\u{1D4EF}",
        "ğ‘®" : "\u{1D4D6}",
        "ğ’ˆ" : "\u{1D4F0}",
        "ğ‘¯" : "\u{1D4D7}",
        "ğ’‰" : "\u{1D4F1}",
        "ğ‘°" : "\u{1D4D8}",
        "ğ’Š" : "\u{1D4F2}",
        "ğ‘±" : "\u{1D4D9}",
        "ğ’‹" : "\u{1D4F3}",
        "ğ‘²" : "\u{1D4DA}",
        "ğ’Œ" : "\u{1D4F4}",
        "ğ‘³" : "\u{1D4DB}",
        "ğ’" : "\u{1D4F5}",
        "ğ‘´" : "\u{1D4DC}",
        "ğ’" : "\u{1D4F6}",
        "ğ‘µ" : "\u{1D4DD}",
        "ğ’" : "\u{1D4F7}",
        "ğ‘¶" : "\u{1D4DE}",
        "ğ’" : "\u{1D4F8}",
        "ğ‘·" : "\u{1D4DF}",
        "ğ’‘" : "\u{1D4F9}",
        "ğ‘¸" : "\u{1D4E0}",
        "ğ’’" : "\u{1D4FA}",
        "ğ‘¹" : "\u{1D4E1}",
        "ğ’“" : "\u{1D4FB}",
        "ğ‘º" : "\u{1D4E2}",
        "ğ’”" : "\u{1D4FC}",
        "ğ‘»" : "\u{1D4E3}",
        "ğ’•" : "\u{1D4FD}",
        "ğ‘¼" : "\u{1D4E4}",
        "ğ’–" : "\u{1D4FE}",
        "ğ‘½" : "\u{1D4E5}",
        "ğ’—" : "\u{1D4FF}",
        "ğ‘¾" : "\u{1D4E6}",
        "ğ’˜" : "\u{1D500}",
        "ğ‘¿" : "\u{1D4E7}",
        "ğ’™" : "\u{1D501}",
        "ğ’€" : "\u{1D4E8}",
        "ğ’š" : "\u{1D502}",
        "ğ’" : "\u{1D4E9}",
        "ğ’›" : "\u{1D503}",

        // Spaces (\:, \;, \quad and \qquad are passed as a single character in mistakes) 
        "\u2710" : spacesChar.add,
        "\u2710\u2710" : spacesChar.add+spacesChar.add,
        "\u2710\u2710\u2710" : spacesChar.add+spacesChar.add+spacesChar.add,
        "\u2710\u2710\u2710\u2710" : spacesChar.add+spacesChar.add+spacesChar.add+spacesChar.add,
        "\u270E" : spacesChar.remove,
        " " : " ",
        "\u000A" : "\u000A",
        "" : ""
    };
    return replaceLetters(arg[0], symbols, initialCommand).concat(extraArgs(arg.slice(1), initialCommand));
};

const mathfrak = (arg, initialCommand) => {
    // mathfrak stands for math fraktur
    // This function converts the list of characters to the corresponding fraktur character
    const symbols = {
        "A" : "\u{1D504}",
        "a" : "\u{1D51E}",
        "B" : "\u{1D505}",
        "b" : "\u{1D51F}",
        "C" : "\u212D",
        "c" : "\u{1D520}",
        "D" : "\u{1D507}",
        "d" : "\u{1D521}",
        "E" : "\u{1D508}",
        "e" : "\u{1D522}",
        "F" : "\u{1D509}",
        "f" : "\u{1D523}",
        "G" : "\u{1D50A}",
        "g" : "\u{1D524}",
        "H" : "\u210C",
        "h" : "\u{1D525}",
        "I" : "\u2111",
        "i" : "\u{1D526}",
        "J" : "\u{1D50D}",
        "j" : "\u{1D527}",
        "K" : "\u{1D50E}",
        "k" : "\u{1D528}",
        "L" : "\u{1D50F}",
        "l" : "\u{1D529}",
        "M" : "\u{1D510}",
        "m" : "\u{1D52A}",
        "N" : "\u{1D511}",
        "n" : "\u{1D52B}",
        "O" : "\u{1D512}",
        "o" : "\u{1D52C}",
        "P" : "\u{1D513}",
        "p" : "\u{1D52D}",
        "Q" : "\u{1D514}",
        "q" : "\u{1D52E}",
        "R" : "\u211C",
        "r" : "\u{1D52F}",
        "S" : "\u{1D516}",
        "s" : "\u{1D530}",
        "T" : "\u{1D517}",
        "t" : "\u{1D531}",
        "U" : "\u{1D518}",
        "u" : "\u{1D532}",
        "V" : "\u{1D519}",
        "v" : "\u{1D533}",
        "W" : "\u{1D51A}",
        "w" : "\u{1D534}",
        "X" : "\u{1D51B}",
        "x" : "\u{1D535}",
        "Y" : "\u{1D51C}",
        "y" : "\u{1D536}",
        "Z" : "\u2128",
        "z" : "\u{1D537}",

        "ğ´" : "\u{1D504}",
        "ğ‘" : "\u{1D51E}",
        "ğµ" : "\u{1D505}",
        "ğ‘" : "\u{1D51F}",
        "ğ¶" : "\u212D",
        "ğ‘" : "\u{1D520}",
        "ğ·" : "\u{1D507}",
        "ğ‘‘" : "\u{1D521}",
        "ğ¸" : "\u{1D508}",
        "ğ‘’" : "\u{1D522}",
        "ğ¹" : "\u{1D509}",
        "ğ‘“" : "\u{1D523}",
        "ğº" : "\u{1D50A}",
        "ğ‘”" : "\u{1D524}",
        "ğ»" : "\u210C",
        "â„" : "\u{1D525}",
        "ğ¼" : "\u2111",
        "ğ‘–" : "\u{1D526}",
        "ğ½" : "\u{1D50D}",
        "ğ‘—" : "\u{1D527}",
        "ğ¾" : "\u{1D50E}",
        "ğ‘˜" : "\u{1D528}",
        "ğ¿" : "\u{1D50F}",
        "ğ‘™" : "\u{1D529}",
        "ğ‘€" : "\u{1D510}",
        "ğ‘š" : "\u{1D52A}",
        "ğ‘" : "\u{1D511}",
        "ğ‘›" : "\u{1D52B}",
        "ğ‘‚" : "\u{1D512}",
        "ğ‘œ" : "\u{1D52C}",
        "ğ‘ƒ" : "\u{1D513}",
        "ğ‘" : "\u{1D52D}",
        "ğ‘„" : "\u{1D514}",
        "ğ‘" : "\u{1D52E}",
        "ğ‘…" : "\u211C",
        "ğ‘Ÿ" : "\u{1D52F}",
        "ğ‘†" : "\u{1D516}",
        "ğ‘ " : "\u{1D530}",
        "ğ‘‡" : "\u{1D517}",
        "ğ‘¡" : "\u{1D531}",
        "ğ‘ˆ" : "\u{1D518}",
        "ğ‘¢" : "\u{1D532}",
        "ğ‘‰" : "\u{1D519}",
        "ğ‘£" : "\u{1D533}",
        "ğ‘Š" : "\u{1D51A}",
        "ğ‘¤" : "\u{1D534}",
        "ğ‘‹" : "\u{1D51B}",
        "ğ‘¥" : "\u{1D535}",
        "ğ‘Œ" : "\u{1D51C}",
        "ğ‘¦" : "\u{1D536}",
        "ğ‘" : "\u2128",
        "ğ‘§" : "\u{1D537}",

        "ğ‘¨" : "\u{1D56C}",
        "ğ’‚" : "\u{1D586}",
        "ğ‘©" : "\u{1D56D}",
        "ğ’ƒ" : "\u{1D587}",
        "ğ‘ª" : "\u{1D56E}",
        "ğ’„" : "\u{1D588}",
        "ğ‘«" : "\u{1D56F}",
        "ğ’…" : "\u{1D589}",
        "ğ‘¬" : "\u{1D570}",
        "ğ’†" : "\u{1D58A}",
        "ğ‘­" : "\u{1D571}",
        "ğ’‡" : "\u{1D58B}",
        "ğ‘®" : "\u{1D572}",
        "ğ’ˆ" : "\u{1D58C}",
        "ğ‘¯" : "\u{1D573}",
        "ğ’‰" : "\u{1D58D}",
        "ğ‘°" : "\u{1D574}",
        "ğ’Š" : "\u{1D58E}",
        "ğ‘±" : "\u{1D575}",
        "ğ’‹" : "\u{1D58F}",
        "ğ‘²" : "\u{1D576}",
        "ğ’Œ" : "\u{1D590}",
        "ğ‘³" : "\u{1D577}",
        "ğ’" : "\u{1D591}",
        "ğ‘´" : "\u{1D578}",
        "ğ’" : "\u{1D592}",
        "ğ‘µ" : "\u{1D579}",
        "ğ’" : "\u{1D593}",
        "ğ‘¶" : "\u{1D57A}",
        "ğ’" : "\u{1D594}",
        "ğ‘·" : "\u{1D57B}",
        "ğ’‘" : "\u{1D595}",
        "ğ‘¸" : "\u{1D57C}",
        "ğ’’" : "\u{1D596}",
        "ğ‘¹" : "\u{1D57D}",
        "ğ’“" : "\u{1D597}",
        "ğ‘º" : "\u{1D57E}",
        "ğ’”" : "\u{1D598}",
        "ğ‘»" : "\u{1D57F}",
        "ğ’•" : "\u{1D599}",
        "ğ‘¼" : "\u{1D580}",
        "ğ’–" : "\u{1D59A}",
        "ğ‘½" : "\u{1D581}",
        "ğ’—" : "\u{1D59B}",
        "ğ‘¾" : "\u{1D582}",
        "ğ’˜" : "\u{1D59C}",
        "ğ‘¿" : "\u{1D583}",
        "ğ’™" : "\u{1D59D}",
        "ğ’€" : "\u{1D584}",
        "ğ’š" : "\u{1D59E}",
        "ğ’" : "\u{1D585}",
        "ğ’›" : "\u{1D59F}",

        // Spaces (\:, \;, \quad and \qquad are passed as a single character in mistakes) 
        "\u2710" : spacesChar.add,
        "\u2710\u2710" : spacesChar.add+spacesChar.add,
        "\u2710\u2710\u2710" : spacesChar.add+spacesChar.add+spacesChar.add,
        "\u2710\u2710\u2710\u2710" : spacesChar.add+spacesChar.add+spacesChar.add+spacesChar.add,
        "\u270E" : spacesChar.remove,
        " " : " ",
        "\u000A" : "\u000A",
        "" : ""
    };
    return replaceLetters(arg[0], symbols, initialCommand).concat(extraArgs(arg.slice(1), initialCommand));
};

const superscript = (arg, initialCommand, forFrac=false) => {
    // Sends input to be converted by replaceLetters
    // This function is by default not called by the frac function
    let output = replaceLetters(arg[0], Superscript, initialCommand, !forFrac);
    if (((output.indexOf(errSymbol) === -1) && (output.filter(e => accents[e] !== undefined).length === 0)) || (forFrac)) {
        return output.concat(extraArgs(arg.slice(1), initialCommand));
    } else {
        return ["^(" + arg[0].join("") + ")"].concat(extraArgs(arg.slice(1), initialCommand));
    };
};

const subscript = (arg, initialCommand, forFrac=false) => {
    // Sends input to be converted by replaceLetters
    // This function is by default not called by the frac function
    let output = replaceLetters(arg[0], Subscript, initialCommand, !forFrac);
    if (((output.indexOf(errSymbol) === -1) && (output.filter(e => accents[e] !== undefined).length === 0)) || (forFrac)) {
        return output.concat(extraArgs(arg.slice(1), initialCommand));
    } else {
        return ["_(" + arg[0].join("") + ")"].concat(extraArgs(arg.slice(1), initialCommand));
    };
};

const textbf = (arg, initialCommand) => {
    // textbf stands for text bold font
    // This function converts the list of characters to the corresponding (text) bold font character
	const symbols = {
        "A" : "\u{1D5D4}",
        "a" : "\u{1D5EE}",
        "B" : "\u{1D5D5}",
        "b" : "\u{1D5EF}",
        "C" : "\u{1D5D6}",
        "c" : "\u{1D5F0}",
        "D" : "\u{1D5D7}",
        "d" : "\u{1D5F1}",
        "E" : "\u{1D5D8}",
        "e" : "\u{1D5F2}",
        "F" : "\u{1D5D9}",
        "f" : "\u{1D5F3}",
        "G" : "\u{1D5DA}",
        "g" : "\u{1D5F4}",
        "H" : "\u{1D5DB}",
        "h" : "\u{1D5F5}",
        "I" : "\u{1D5DC}",
        "i" : "\u{1D5F6}",
        "J" : "\u{1D5DD}",
        "j" : "\u{1D5F7}",
        "K" : "\u{1D5DE}",
        "k" : "\u{1D5F8}",
        "L" : "\u{1D5DF}",
        "l" : "\u{1D5F9}",
        "M" : "\u{1D5E0}",
        "m" : "\u{1D5FA}",
        "N" : "\u{1D5E1}",
        "n" : "\u{1D5FB}",
        "O" : "\u{1D5E2}",
        "o" : "\u{1D5FC}",
        "P" : "\u{1D5E3}",
        "p" : "\u{1D5FD}",
        "Q" : "\u{1D5E4}",
        "q" : "\u{1D5FE}",
        "R" : "\u{1D5E5}",
        "r" : "\u{1D5FF}",
        "S" : "\u{1D5E6}",
        "s" : "\u{1D600}",
        "T" : "\u{1D5E7}",
        "t" : "\u{1D601}",
        "U" : "\u{1D5E8}",
        "u" : "\u{1D602}",
        "V" : "\u{1D5E9}",
        "v" : "\u{1D603}",
        "W" : "\u{1D5EA}",
        "w" : "\u{1D604}",
        "X" : "\u{1D5EB}",
        "x" : "\u{1D605}",
        "Y" : "\u{1D5EC}",
        "y" : "\u{1D606}",
        "Z" : "\u{1D5ED}",
        "z" : "\u{1D607}",

        "ğ´" : "\u{1D5D4}",
        "ğ‘" : "\u{1D5EE}",
        "ğµ" : "\u{1D5D5}",
        "ğ‘" : "\u{1D5EF}",
        "ğ¶" : "\u{1D5D6}",
        "ğ‘" : "\u{1D5F0}",
        "ğ·" : "\u{1D5D7}",
        "ğ‘‘" : "\u{1D5F1}",
        "ğ¸" : "\u{1D5D8}",
        "ğ‘’" : "\u{1D5F2}",
        "ğ¹" : "\u{1D5D9}",
        "ğ‘“" : "\u{1D5F3}",
        "ğº" : "\u{1D5DA}",
        "ğ‘”" : "\u{1D5F4}",
        "ğ»" : "\u{1D5DB}",
        "â„" : "\u{1D5F5}",
        "ğ¼" : "\u{1D5DC}",
        "ğ‘–" : "\u{1D5F6}",
        "ğ½" : "\u{1D5DD}",
        "ğ‘—" : "\u{1D5F7}",
        "ğ¾" : "\u{1D5DE}",
        "ğ‘˜" : "\u{1D5F8}",
        "ğ¿" : "\u{1D5DF}",
        "ğ‘™" : "\u{1D5F9}",
        "ğ‘€" : "\u{1D5E0}",
        "ğ‘š" : "\u{1D5FA}",
        "ğ‘" : "\u{1D5E1}",
        "ğ‘›" : "\u{1D5FB}",
        "ğ‘‚" : "\u{1D5E2}",
        "ğ‘œ" : "\u{1D5FC}",
        "ğ‘ƒ" : "\u{1D5E3}",
        "ğ‘" : "\u{1D5FD}",
        "ğ‘„" : "\u{1D5E4}",
        "ğ‘" : "\u{1D5FE}",
        "ğ‘…" : "\u{1D5E5}",
        "ğ‘Ÿ" : "\u{1D5FF}",
        "ğ‘†" : "\u{1D5E6}",
        "ğ‘ " : "\u{1D600}",
        "ğ‘‡" : "\u{1D5E7}",
        "ğ‘¡" : "\u{1D601}",
        "ğ‘ˆ" : "\u{1D5E8}",
        "ğ‘¢" : "\u{1D602}",
        "ğ‘‰" : "\u{1D5E9}",
        "ğ‘£" : "\u{1D603}",
        "ğ‘Š" : "\u{1D5EA}",
        "ğ‘¤" : "\u{1D604}",
        "ğ‘‹" : "\u{1D5EB}",
        "ğ‘¥" : "\u{1D605}",
        "ğ‘Œ" : "\u{1D5EC}",
        "ğ‘¦" : "\u{1D606}",
        "ğ‘" : "\u{1D5ED}",
        "ğ‘§" : "\u{1D607}",

        "ğ˜ˆ" : "\u{1D63C}",
        "ğ˜¢" : "\u{1D656}",
        "ğ˜‰" : "\u{1D63D}",
        "ğ˜£" : "\u{1D657}",
        "ğ˜Š" : "\u{1D63E}",
        "ğ˜¤" : "\u{1D658}",
        "ğ˜‹" : "\u{1D63F}",
        "ğ˜¥" : "\u{1D659}",
        "ğ˜Œ" : "\u{1D640}",
        "ğ˜¦" : "\u{1D65A}",
        "ğ˜" : "\u{1D641}",
        "ğ˜§" : "\u{1D65B}",
        "ğ˜" : "\u{1D642}",
        "ğ˜¨" : "\u{1D65C}",
        "ğ˜" : "\u{1D643}",
        "ğ˜©" : "\u{1D65D}",
        "ğ˜" : "\u{1D644}",
        "ğ˜ª" : "\u{1D65E}",
        "ğ˜‘" : "\u{1D645}",
        "ğ˜«" : "\u{1D65F}",
        "ğ˜’" : "\u{1D646}",
        "ğ˜¬" : "\u{1D660}",
        "ğ˜“" : "\u{1D647}",
        "ğ˜­" : "\u{1D661}",
        "ğ˜”" : "\u{1D648}",
        "ğ˜®" : "\u{1D662}",
        "ğ˜•" : "\u{1D649}",
        "ğ˜¯" : "\u{1D663}",
        "ğ˜–" : "\u{1D64A}",
        "ğ˜°" : "\u{1D664}",
        "ğ˜—" : "\u{1D64B}",
        "ğ˜±" : "\u{1D665}",
        "ğ˜˜" : "\u{1D64C}",
        "ğ˜²" : "\u{1D666}",
        "ğ˜™" : "\u{1D64D}",
        "ğ˜³" : "\u{1D667}",
        "ğ˜š" : "\u{1D64E}",
        "ğ˜´" : "\u{1D668}",
        "ğ˜›" : "\u{1D64F}",
        "ğ˜µ" : "\u{1D669}",
        "ğ˜œ" : "\u{1D650}",
        "ğ˜¶" : "\u{1D66A}",
        "ğ˜" : "\u{1D651}",
        "ğ˜·" : "\u{1D66B}",
        "ğ˜" : "\u{1D652}",
        "ğ˜¸" : "\u{1D66C}",
        "ğ˜Ÿ" : "\u{1D653}",
        "ğ˜¹" : "\u{1D66D}",
        "ğ˜ " : "\u{1D654}",
        "ğ˜º" : "\u{1D66E}",
        "ğ˜¡" : "\u{1D655}",
        "ğ˜»" : "\u{1D66F}",

        "0" : "\u{1D7EC}",
        "1" : "\u{1D7ED}",
        "2" : "\u{1D7EE}",
        "3" : "\u{1D7EF}",
        "4" : "\u{1D7F0}",
        "5" : "\u{1D7F1}",
        "6" : "\u{1D7F2}",
        "7" : "\u{1D7F3}",
        "8" : "\u{1D7F4}",
        "9" : "\u{1D7F5}",

        // These symbols don't exist in textbf, but doesn't output an error
        "." : ".",
        "," : ",",
        "'" : "'",
        "â€²" : "'",
        '"' : '"',
        "â€³" : '"',
        "!" : "!",
        "?" : "?",
        "-" : "-",
        "\u2212" : "\u2212",
        "_" : "_",
        "^" : "^",
        "/" : "/",
        "+" : "+",
        "=" : "=",
        "$" : "$",
        "Â¢" : "Â¢",
        "Â£" : "Â£",
        "%" : "%",
        "&" : "&",
        "*" : "*",
        "@" : "@",
        "#" : "#",
        "|" : "|",
        "\\" : "\\",
        ":" : ":",
        "âˆ¶" : ":",
        ";" : ";",
        ">" : ">",
        "<" : "<",
        "Â°" : "Â°",
        "(" : "(",
        ")" : ")",
        "[" : "[",
        "]" : "]",
        "{" : "{",
        "}" : "}",

        "\u2710" : spacesChar.add,
        "\u270E" : spacesChar.remove,
		" " : spacesChar.add,
        "\u000A" : "\u000A",
        "" : ""
	};
	return replaceLetters(arg[0], symbols, initialCommand).concat(extraArgs(arg.slice(1), initialCommand));
};

const textit = (arg, initialCommand) => {
    // textit stands for text italic
    // This function converts the list of characters to the corresponding italic character
    const symbols = {
        "A" : "\u{1D608}",
        "a" : "\u{1D622}",
        "B" : "\u{1D609}",
        "b" : "\u{1D623}",
        "C" : "\u{1D60A}",
        "c" : "\u{1D624}",
        "D" : "\u{1D60B}",
        "d" : "\u{1D625}",
        "E" : "\u{1D60C}",
        "e" : "\u{1D626}",
        "F" : "\u{1D60D}",
        "f" : "\u{1D627}",
        "G" : "\u{1D60E}",
        "g" : "\u{1D628}",
        "H" : "\u{1D60F}",
        "h" : "\u{1D629}",
        "I" : "\u{1D610}",
        "i" : "\u{1D62A}",
        "J" : "\u{1D611}",
        "j" : "\u{1D62B}",
        "K" : "\u{1D612}",
        "k" : "\u{1D62C}",
        "L" : "\u{1D613}",
        "l" : "\u{1D62D}",
        "M" : "\u{1D614}",
        "m" : "\u{1D62E}",
        "N" : "\u{1D615}",
        "n" : "\u{1D62F}",
        "O" : "\u{1D616}",
        "o" : "\u{1D630}",
        "P" : "\u{1D617}",
        "p" : "\u{1D631}",
        "Q" : "\u{1D618}",
        "q" : "\u{1D632}",
        "R" : "\u{1D619}",
        "r" : "\u{1D633}",
        "S" : "\u{1D61A}",
        "s" : "\u{1D634}",
        "T" : "\u{1D61B}",
        "t" : "\u{1D635}",
        "U" : "\u{1D61C}",
        "u" : "\u{1D636}",
        "V" : "\u{1D61D}",
        "v" : "\u{1D637}",
        "W" : "\u{1D61E}",
        "w" : "\u{1D638}",
        "X" : "\u{1D61F}",
        "x" : "\u{1D639}",
        "Y" : "\u{1D620}",
        "y" : "\u{1D63A}",
        "Z" : "\u{1D621}",
        "z" : "\u{1D63B}",

        "ğ´" : "\u{1D608}",
        "ğ‘" : "\u{1D622}",
        "ğµ" : "\u{1D609}",
        "ğ‘" : "\u{1D623}",
        "ğ¶" : "\u{1D60A}",
        "ğ‘" : "\u{1D624}",
        "ğ·" : "\u{1D60B}",
        "ğ‘‘" : "\u{1D625}",
        "ğ¸" : "\u{1D60C}",
        "ğ‘’" : "\u{1D626}",
        "ğ¹" : "\u{1D60D}",
        "ğ‘“" : "\u{1D627}",
        "ğº" : "\u{1D60E}",
        "ğ‘”" : "\u{1D628}",
        "ğ»" : "\u{1D60F}",
        "â„" : "\u{1D629}",
        "ğ¼" : "\u{1D610}",
        "ğ‘–" : "\u{1D62A}",
        "ğ½" : "\u{1D611}",
        "ğ‘—" : "\u{1D62B}",
        "ğ¾" : "\u{1D612}",
        "ğ‘˜" : "\u{1D62C}",
        "ğ¿" : "\u{1D613}",
        "ğ‘™" : "\u{1D62D}",
        "ğ‘€" : "\u{1D614}",
        "ğ‘š" : "\u{1D62E}",
        "ğ‘" : "\u{1D615}",
        "ğ‘›" : "\u{1D62F}",
        "ğ‘‚" : "\u{1D616}",
        "ğ‘œ" : "\u{1D630}",
        "ğ‘ƒ" : "\u{1D617}",
        "ğ‘" : "\u{1D631}",
        "ğ‘„" : "\u{1D618}",
        "ğ‘" : "\u{1D632}",
        "ğ‘…" : "\u{1D619}",
        "ğ‘Ÿ" : "\u{1D633}",
        "ğ‘†" : "\u{1D61A}",
        "ğ‘ " : "\u{1D634}",
        "ğ‘‡" : "\u{1D61B}",
        "ğ‘¡" : "\u{1D635}",
        "ğ‘ˆ" : "\u{1D61C}",
        "ğ‘¢" : "\u{1D636}",
        "ğ‘‰" : "\u{1D61D}",
        "ğ‘£" : "\u{1D637}",
        "ğ‘Š" : "\u{1D61E}",
        "ğ‘¤" : "\u{1D638}",
        "ğ‘‹" : "\u{1D61F}",
        "ğ‘¥" : "\u{1D639}",
        "ğ‘Œ" : "\u{1D620}",
        "ğ‘¦" : "\u{1D63A}",
        "ğ‘" : "\u{1D621}",
        "ğ‘§" : "\u{1D63B}",

        "ğ—”" : "\u{1D63C}",
        "ğ—®" : "\u{1D656}",
        "ğ—•" : "\u{1D63D}",
        "ğ—¯" : "\u{1D657}",
        "ğ—–" : "\u{1D63E}",
        "ğ—°" : "\u{1D658}",
        "ğ——" : "\u{1D63F}",
        "ğ—±" : "\u{1D659}",
        "ğ—˜" : "\u{1D640}",
        "ğ—²" : "\u{1D65A}",
        "ğ—™" : "\u{1D641}",
        "ğ—³" : "\u{1D65B}",
        "ğ—š" : "\u{1D642}",
        "ğ—´" : "\u{1D65C}",
        "ğ—›" : "\u{1D643}",
        "ğ—µ" : "\u{1D65D}",
        "ğ—œ" : "\u{1D644}",
        "ğ—¶" : "\u{1D65E}",
        "ğ—" : "\u{1D645}",
        "ğ—·" : "\u{1D65F}",
        "ğ—" : "\u{1D646}",
        "ğ—¸" : "\u{1D660}",
        "ğ—Ÿ" : "\u{1D647}",
        "ğ—¹" : "\u{1D661}",
        "ğ— " : "\u{1D648}",
        "ğ—º" : "\u{1D662}",
        "ğ—¡" : "\u{1D649}",
        "ğ—»" : "\u{1D663}",
        "ğ—¢" : "\u{1D64A}",
        "ğ—¼" : "\u{1D664}",
        "ğ—£" : "\u{1D64B}",
        "ğ—½" : "\u{1D665}",
        "ğ—¤" : "\u{1D64C}",
        "ğ—¾" : "\u{1D666}",
        "ğ—¥" : "\u{1D64D}",
        "ğ—¿" : "\u{1D667}",
        "ğ—¦" : "\u{1D64E}",
        "ğ˜€" : "\u{1D668}",
        "ğ—§" : "\u{1D64F}",
        "ğ˜" : "\u{1D669}",
        "ğ—¨" : "\u{1D650}",
        "ğ˜‚" : "\u{1D66A}",
        "ğ—©" : "\u{1D651}",
        "ğ˜ƒ" : "\u{1D66B}",
        "ğ—ª" : "\u{1D652}",
        "ğ˜„" : "\u{1D66C}",
        "ğ—«" : "\u{1D653}",
        "ğ˜…" : "\u{1D66D}",
        "ğ—¬" : "\u{1D654}",
        "ğ˜†" : "\u{1D66E}",
        "ğ—­" : "\u{1D655}",
        "ğ˜‡" : "\u{1D66F}",

        "ğŸ¬" : "ğŸ¬",
        "ğŸ­" : "ğŸ­",
        "ğŸ®" : "ğŸ®",
        "ğŸ¯" : "ğŸ¯",
        "ğŸ°" : "ğŸ°",
        "ğŸ±" : "ğŸ±",
        "ğŸ²" : "ğŸ²",
        "ğŸ³" : "ğŸ³",
        "ğŸ´" : "ğŸ´",
        "ğŸµ" : "ğŸµ",

        // These symbols don't exist in textit, but doesn't output an error
        "." : ".",
        "," : ",",
        "'" : "'",
        "â€²" : "'",
        '"' : '"',
        "â€³" : '"',
        "!" : "!",
        "?" : "?",
        "-" : "-",
        "\u2212" : "\u2212",
        "_" : "_",
        "^" : "^",
        "/" : "/",
        "+" : "+",
        "=" : "=",
        "$" : "$",
        "Â¢" : "Â¢",
        "Â£" : "Â£",
        "%" : "%",
        "&" : "&",
        "*" : "*",
        "@" : "@",
        "#" : "#",
        "|" : "|",
        "\\" : "\\",
        ":" : ":",
        "âˆ¶" : ":",
        ";" : ";",
        ">" : ">",
        "<" : "<",
        "Â°" : "Â°",
        "(" : "(",
        ")" : ")",
        "[" : "[",
        "]" : "]",
        "{" : "{",
        "}" : "}",
        "0" : "0",
        "1" : "1",
        "2" : "2",
        "3" : "3",
        "4" : "4",
        "5" : "5",
        "6" : "6",
        "7" : "7",
        "8" : "8",
        "9" : "9",

        "\u2710" : spacesChar.add,
        "\u270E" : spacesChar.remove,
        " " : spacesChar.add,
        "\u000A" : "\u000A",
        "" : ""
	};
	return replaceLetters(arg[0], symbols, initialCommand).concat(extraArgs(arg.slice(1), initialCommand));
};

const texttt = (arg, initialCommand) => {
    // texttt stands for text typewriter
    // This function converts the list of characters to the corresponding typewriter character
    const symbols = {
        "A" : "\u{1D670}",
        "a" : "\u{1D68A}",
        "B" : "\u{1D671}",
        "b" : "\u{1D68B}",
        "C" : "\u{1D672}",
        "c" : "\u{1D68C}",
        "D" : "\u{1D673}",
        "d" : "\u{1D68D}",
        "E" : "\u{1D674}",
        "e" : "\u{1D68E}",
        "F" : "\u{1D675}",
        "f" : "\u{1D68F}",
        "G" : "\u{1D676}",
        "g" : "\u{1D690}",
        "H" : "\u{1D677}",
        "h" : "\u{1D691}",
        "I" : "\u{1D678}",
        "i" : "\u{1D692}",
        "J" : "\u{1D679}",
        "j" : "\u{1D693}",
        "K" : "\u{1D67A}",
        "k" : "\u{1D694}",
        "L" : "\u{1D67B}",
        "l" : "\u{1D695}",
        "M" : "\u{1D67C}",
        "m" : "\u{1D696}",
        "N" : "\u{1D67D}",
        "n" : "\u{1D697}",
        "O" : "\u{1D67E}",
        "o" : "\u{1D698}",
        "P" : "\u{1D67F}",
        "p" : "\u{1D699}",
        "Q" : "\u{1D680}",
        "q" : "\u{1D69A}",
        "R" : "\u{1D681}",
        "r" : "\u{1D69B}",
        "S" : "\u{1D682}",
        "s" : "\u{1D69C}",
        "T" : "\u{1D683}",
        "t" : "\u{1D69D}",
        "U" : "\u{1D684}",
        "u" : "\u{1D69E}",
        "V" : "\u{1D685}",
        "v" : "\u{1D69F}",
        "W" : "\u{1D686}",
        "w" : "\u{1D6A0}",
        "X" : "\u{1D687}",
        "x" : "\u{1D6A1}",
        "Y" : "\u{1D688}",
        "y" : "\u{1D6A2}",
        "Z" : "\u{1D689}",
        "z" : "\u{1D6A3}",

        "ğ´" : "\u{1D670}",
        "ğ‘" : "\u{1D68A}",
        "ğµ" : "\u{1D671}",
        "ğ‘" : "\u{1D68B}",
        "ğ¶" : "\u{1D672}",
        "ğ‘" : "\u{1D68C}",
        "ğ·" : "\u{1D673}",
        "ğ‘‘" : "\u{1D68D}",
        "ğ¸" : "\u{1D674}",
        "ğ‘’" : "\u{1D68E}",
        "ğ¹" : "\u{1D675}",
        "ğ‘“" : "\u{1D68F}",
        "ğº" : "\u{1D676}",
        "ğ‘”" : "\u{1D690}",
        "ğ»" : "\u{1D677}",
        "â„" : "\u{1D691}",
        "ğ¼" : "\u{1D678}",
        "ğ‘–" : "\u{1D692}",
        "ğ½" : "\u{1D679}",
        "ğ‘—" : "\u{1D693}",
        "ğ¾" : "\u{1D67A}",
        "ğ‘˜" : "\u{1D694}",
        "ğ¿" : "\u{1D67B}",
        "ğ‘™" : "\u{1D695}",
        "ğ‘€" : "\u{1D67C}",
        "ğ‘š" : "\u{1D696}",
        "ğ‘" : "\u{1D67D}",
        "ğ‘›" : "\u{1D697}",
        "ğ‘‚" : "\u{1D67E}",
        "ğ‘œ" : "\u{1D698}",
        "ğ‘ƒ" : "\u{1D67F}",
        "ğ‘" : "\u{1D699}",
        "ğ‘„" : "\u{1D680}",
        "ğ‘" : "\u{1D69A}",
        "ğ‘…" : "\u{1D681}",
        "ğ‘Ÿ" : "\u{1D69B}",
        "ğ‘†" : "\u{1D682}",
        "ğ‘ " : "\u{1D69C}",
        "ğ‘‡" : "\u{1D683}",
        "ğ‘¡" : "\u{1D69D}",
        "ğ‘ˆ" : "\u{1D684}",
        "ğ‘¢" : "\u{1D69E}",
        "ğ‘‰" : "\u{1D685}",
        "ğ‘£" : "\u{1D69F}",
        "ğ‘Š" : "\u{1D686}",
        "ğ‘¤" : "\u{1D6A0}",
        "ğ‘‹" : "\u{1D687}",
        "ğ‘¥" : "\u{1D6A1}",
        "ğ‘Œ" : "\u{1D688}",
        "ğ‘¦" : "\u{1D6A2}",
        "ğ‘" : "\u{1D689}",
        "ğ‘§" : "\u{1D6A3}",

        "0" : "\u{1D7F6}",
        "1" : "\u{1D7F7}",
        "2" : "\u{1D7F8}",
        "3" : "\u{1D7F9}",
        "4" : "\u{1D7FA}",
        "5" : "\u{1D7FB}",
        "6" : "\u{1D7FC}",
        "7" : "\u{1D7FD}",
        "8" : "\u{1D7FE}",
        "9" : "\u{1D7FF}",

        // These symbols don't exist in texttt, but don't output errors
        "." : ".",
        "," : ",",
        "'" : "'",
        "â€²" : "'",
        '"' : '"',
        "â€³" : '"',
        "!" : "!",
        "?" : "?",
        "-" : "-",
        "\u2212" : "\u2212",
        "_" : "_",
        "^" : "^",
        "/" : "/",
        "+" : "+",
        "=" : "=",
        "$" : "$",
        "Â¢" : "Â¢",
        "Â£" : "Â£",
        "%" : "%",
        "&" : "&",
        "*" : "*",
        "@" : "@",
        "#" : "#",
        "|" : "|",
        "\\" : "\\",
        ":" : ":",
        "âˆ¶" : ":",
        ";" : ";",
        ">" : ">",
        "<" : "<",
        "Â°" : "Â°",
        "(" : "(",
        ")" : ")",
        "[" : "[",
        "]" : "]",
        "{" : "{",
        "}" : "}",

        "\u2710" : spacesChar.add,
        "\u270E" : spacesChar.remove,
        " " : spacesChar.add,
        "\u000A" : "\u000A",
        "" : ""
    };
    return replaceLetters(arg[0], symbols, initialCommand).concat(extraArgs(arg.slice(1), initialCommand));
};

const text = (arg, initialCommand) => {
    // This function doesn't change the output (i.e. "abc" -> "abc")
    const symbols = {
        "A" : "A",
        "a" : "a",
        "B" : "B",
        "b" : "b",
        "C" : "C",
        "c" : "c",
        "D" : "D",
        "d" : "d",
        "E" : "E",
        "e" : "e",
        "F" : "F",
        "f" : "f",
        "G" : "G",
        "g" : "g",
        "H" : "H",
        "h" : "h",
        "I" : "I",
        "i" : "i",
        "J" : "J",
        "j" : "j",
        "K" : "K",
        "k" : "k",
        "L" : "L",
        "l" : "l",
        "M" : "M",
        "m" : "m",
        "N" : "N",
        "n" : "n",
        "O" : "O",
        "o" : "o",
        "P" : "P",
        "p" : "p",
        "Q" : "Q",
        "q" : "q",
        "R" : "R",
        "r" : "r",
        "S" : "S",
        "s" : "s",
        "T" : "T",
        "t" : "t",
        "U" : "U",
        "u" : "u",
        "V" : "V",
        "v" : "v",
        "W" : "W",
        "w" : "w",
        "X" : "X",
        "x" : "x",
        "Y" : "Y",
        "y" : "y",
        "Z" : "Z",
        "z" : "z",

        "ğ´" : "A",
        "ğ‘" : "a",
        "ğµ" : "B",
        "ğ‘" : "b",
        "ğ¶" : "C",
        "ğ‘" : "c",
        "ğ·" : "D",
        "ğ‘‘" : "d",
        "ğ¸" : "E",
        "ğ‘’" : "e",
        "ğ¹" : "F",
        "ğ‘“" : "f",
        "ğº" : "G",
        "ğ‘”" : "g",
        "ğ»" : "H",
        "â„" : "h",
        "ğ¼" : "I",
        "ğ‘–" : "i",
        "ğ½" : "J",
        "ğ‘—" : "j",
        "ğ¾" : "K",
        "ğ‘˜" : "k",
        "ğ¿" : "L",
        "ğ‘™" : "l",
        "ğ‘€" : "M",
        "ğ‘š" : "m",
        "ğ‘" : "N",
        "ğ‘›" : "n",
        "ğ‘‚" : "O",
        "ğ‘œ" : "o",
        "ğ‘ƒ" : "P",
        "ğ‘" : "p",
        "ğ‘„" : "Q",
        "ğ‘" : "q",
        "ğ‘…" : "R",
        "ğ‘Ÿ" : "r",
        "ğ‘†" : "S",
        "ğ‘ " : "s",
        "ğ‘‡" : "T",
        "ğ‘¡" : "t",
        "ğ‘ˆ" : "U",
        "ğ‘¢" : "u",
        "ğ‘‰" : "V",
        "ğ‘£" : "v",
        "ğ‘Š" : "W",
        "ğ‘¤" : "w",
        "ğ‘‹" : "X",
        "ğ‘¥" : "x",
        "ğ‘Œ" : "Y",
        "ğ‘¦" : "y",
        "ğ‘" : "Z",
        "ğ‘§" : "z",

        "0" : "0",
        "1" : "1",
        "2" : "2",
        "3" : "3",
        "4" : "4",
        "5" : "5",
        "6" : "6",
        "7" : "7",
        "8" : "8",
        "9" : "9",

        "." : ".",
        "," : ",",
        "'" : "'",
        "â€²" : "'",
        '"' : '"',
        "â€³" : '"',
        "!" : "!",
        "?" : "?",
        "-" : "-",
        "\u2212" : "\u2212",
        "_" : "_",
        "^" : "^",
        "/" : "/",
        "+" : "+",
        "=" : "=",
        "$" : "$",
        "Â¢" : "Â¢",
        "Â£" : "Â£",
        "%" : "%",
        "&" : "&",
        "*" : "*",
        "@" : "@",
        "#" : "#",
        "|" : "|",
        "\\" : "\\",
        ":" : ":",
        "âˆ¶" : ":",
        ";" : ";",
        ">" : ">",
        "<" : "<",
        "Â°" : "Â°",
        "(" : "(",
        ")" : ")",
        "[" : "[",
        "]" : "]",
        "{" : "{",
        "}" : "}",

        "\u2710" : spacesChar.add,
        "\u270E" : spacesChar.remove,
        " " : spacesChar.add,
        "\u000A" : "\u000A",
        "" : ""
    };
    return replaceLetters(arg[0], symbols, initialCommand).concat(extraArgs(arg.slice(1), initialCommand));
};

const hspace = (arg, initialCommand) => {
    // hspace stands for horizontal space
    // Adds the number of space specified in 'arg'
    let spaces = [];
    const num = arg[0].join("");
    if (num * 0 !== 0) {
        spaces.push(mistakes(initialCommand + "{" + num + "}", undefined, "Argument must be a number"));
    } else {
        for (let i=0; i<parseInt(num); i++) {
            spaces.push(spacesChar.add);
        };
    };
    return spaces.concat(extraArgs(arg.slice(1), initialCommand));
};

const vskip = (arg, initialCommand) => {
    // vskip stands for vertical skip
    // Adds the number of linebreaks specified in 'arg'
    let skips = [];
    const num = arg[0].join("");
    if (num * 0 !== 0) {
        skips.push(mistakes(initialCommand + "{" + num + "}", undefined, "Argument must be a number"));
    } else {
        for (let i=0; i<parseInt(num); i++) {
            skips.push("\u000A");
        };
    };
    return skips.concat(extraArgs(arg.slice(1), initialCommand));
};

const phantom = (arg, initialCommand) => {
    // Outputs the same number of spaces as the length of the argument
    // e.g. \phantom{abc} -> 3 spaces and \phantom{\int} -> 1 space
    let spaces = [];
    for (let i=0; i<arg[0].length; i++) {
        spaces.push(spacesChar.add);
    };
    if (arg[0].includes(errSymbol)) {
        mistakes(initialCommand + "{" + arg[0].join("") + "}", undefined, "Undefined argument");
    };
    return spaces.concat(extraArgs(arg.slice(1), initialCommand));
};

const mathord = (arg, initialCommand) => {
    // Removes spaces around arg
    // \mathord{arg} is equivalent to {arg} and \! arg \!
    let output = [];
    for (let i in arg) {
        output.push(spacesChar.remove, arg[i].join(""), spacesChar.remove);
        if (arg[i].includes(errSymbol)) {
            mistakes(initialCommand + "{" + arg[i].join("") + "}", undefined, "Undefined argument");
        };
    };
    return output;
};

const sqrt = (arg, initialCommand) => {
    // sqrt stands for square root
    const numStart = parseInt(initialCommand.indexOf("["));
    const numEnd = parseInt(initialCommand.indexOf("]"));
    let rootNum;
    if ((numStart === -1) || (numEnd === -1)) {
        if ((numStart === -1) && (numEnd === -1)) {
            rootNum = undefined;
        } else {
            mistakes(initialCommand + " should take the form \\sqrt[n]{x}", undefined, "â¿âˆšğ‘¥");
            return [addSymbol(undefined)];
        };
    } else {
        rootNum = initialCommand.substring(numStart + 1, numEnd);
    };
    let output = "";
    switch (rootNum) {
        // There's already a unicode symbol for square root, cube root and 4th root
        // If rootNum is different than those, the symbol is built
        case "3":
            output += "\u221B";
            break;
        case "4":
            output += "\u221C";
            break;
        case undefined:
            output += "\u221A";
            break;
        default:
            output += addSymbol(superscript([rootNum.split("")], initialCommand)) + "\u221A";
    };
    if (arg.length > 0) {
        if (arg[0].length >= 2) {
            output += "(" + addSymbolArray(arg[0], initialCommand + "{" + arg[0].join("") + "}") + ")";
        } else {
            output += addSymbolArray(arg[0], initialCommand + "{" + arg[0].join("") + "}");
        };
        return [output].concat(extraArgs(arg.slice(1), initialCommand));
    } else  {
        return [output];
    }
};

const frac = (arg, initialCommand) => {
    // Used to make a fraction
    // If a character doesn't exist in superscript or subscript, it outputs the fraction in the format f(x)/g(x)
    let output = [];
    if (arg.length < 2) {
        mistakes("\\frac{}{}", undefined, "Two arguments needed");
        return [errSymbol];
    };
    output.push(...addSymbol(superscript([arg[0]], initialCommand, true), true), "\u2215");
    output.push(...addSymbol(subscript([arg[1]], initialCommand, true), true));
    if ((output.indexOf(errSymbol) === -1) && (output.filter(e => accents[e] !== undefined).length === 0)) {
        return output.concat(extraArgs(arg.slice(2), initialCommand));
    } else {
        // TODO: Why???
        if (arg.join("").includes(spacesChar.add)) {
            const spaces = arg.filter(c => {return c.includes(spacesChar.add)});
            for (let i in spaces) {
                mistakes(initialCommand + "{" + arg.join("") + "}", undefined, spaces[i]);
            };
        };
        output = ["(", 
                  addSymbolArray(arg[0], "\\frac{" + arg[0].join("") + "}" + "{" + arg[1].join("") + "}"), 
                  "/", 
                  addSymbolArray(arg[1], "\\frac{" + arg[0].join("") + "}" + "{" + arg[1].join("") + "}"),
                   ")"];
        return output.concat(extraArgs(arg.slice(2), initialCommand));
    };
};

const singleCharFrac = (arg, initialCommand) => {
    // Some fractions already exists as unicode symbols they can be accessed via this function
    let noSpaceArg = arg.slice(0,2).join("").replace(/ /g, "")
                                            .replace(/\u000A/g, "");
    const fractions = {
        "12" : "\u00BD",
        "17" : "â…",
        "19" : "â…‘",
        "110" : "â…’",
        "13"  :"â…“",
        "23" : "â…”",
        "15" : "â…•",
        "25" : "â…–",
        "35" : "â…—",
        "45" : "â…˜",
        "16" : "â…™",
        "56" : "â…š",
        "18" : "â…›",
        "38" : "â…œ",
        "58" : "â…",
        "78" : "â…",
        "ac" : "\u2100",
        "as" : "\u2101",
        "co" : "\u2105",
        "cu" : "\u2106"
    };
    let output = fractions[noSpaceArg];
    return (output !== undefined) ? [output].concat(extraArgs(arg.slice(2), initialCommand)) : frac(arg, initialCommand);
};

const pmod = (arg, initialCommand) => {
    // returns ' (mod arg)'
    return [spacesChar.add+"(mod"+spacesChar.add + arg[0].join("") + ")"].concat(extraArgs(arg.slice(1), initialCommand));
};

const today = () => {
    // returns today's date
    let date = new Date();
    let month = date.toLocaleString('en', {month: 'long'});  // Will change to 'default' when many languages will be supported
    return month + " " + date.getDate() + ", " + date.getFullYear();
};

// These functions call combineSymbols with a predetermined symbol

const overline = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0305")};

const underline = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0332")};

const vec = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u20D7")};

const hvec = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u20D1")};

const overfrown = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0361", "\u0361")};

const oversmile = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u035D", "\u035D")};

const undersmile = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u035C", "\u035C")};

const hat = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0302")};

const not = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0338")};

const tilde = (arg, initialCommand) => {if ((arg == "\u27F6") ||Â (arg == "\u2192")) {return ["\u2972"]} else {return combineSymbols(arg, initialCommand, "\u0303", "\u0360")}};

const dot = (arg, initialCommand) => {if ((arg == "=") || (arg == "\u003D")) {return ["\u2250"]} else if (arg == "\u2261") {return ["\u2A67"]} else {return combineSymbols(arg, initialCommand, "\u0307")}};

const ddot = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0308")};

const underarrow = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0362", "\u0362")};

const underharpoon = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u20EC")};

const acute = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0301")};

const grave = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0300")};

const bar = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0304")};

const breve = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0306")};

const caron = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u030C")};

const doubleAccute = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u030B")};

const ringAbove = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u030A")};

const cedilla = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0327")};

const dotBelow = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0323")};

const ogonek = (arg, initialCommand) => {return combineSymbols(arg, initialCommand, "\u0328")};

const stackSymbols = (arg, initialCommand, dict) => {
    // Used in overset, underset and stackrel
    // Returns the first argument above or below the symbol in the middle of the second argument
    if (arg.length < 2) {
        mistakes(initialCommand+"{}{}", undefined, "Two arguments needed");
        return [errSymbol];
    };
    let rel = arg[0];
    let mid = arg[1];
    if (rel.length > 1) {
        return mistakes(initialCommand+"{"+rel.join("")+"}{"+mid.join("")+"}", undefined, "Length of first argument must be one.");
    };
    mistakes(initialCommand+"{"+rel.join("")+"}{"+mid.join("")+"}", dict[rel[0]], (rel[0] !== undefined) ? rel[0] : "Argument doesn't exist");
    mid[Math.floor(mid.length/2)] += (dict[rel[0]] !== undefined) ? dict[rel[0]] : "";
    return [mid.join("")].concat(extraArgs(arg.slice(2), initialCommand));
};

const overset = (arg, initialCommand) => {
    return stackSymbols(arg, initialCommand, Above);
};

const stackrel = (arg, initialCommand) => {
    return overset(arg, initialCommand);
};

const underset = (arg, initialCommand) => {
    return stackSymbols(arg, initialCommand, Below);
};


//-----------------------------------------------------//


/** Dictionaries **/

// Space: internally represented with \u2710 (âœ), but switched to a real space before output
// Remove space: if there's one surrounding \! \u270E (âœ) will be removed before the output
const spacesChar = {add: "\u2710", remove: "\u270E"};

// mathDictionary is the main dict for converting commands into symbols
const mathDictionary = {
    // Math operators
    "\\times" : "\u00D7",
    "\\rtimes" : "\u22CA",
    "\\ltimes" : "\u22C9",
    "\\div" : "\u00F7",
    "\\longdiv" : "\u27CC",
    "\\int" : "\u222B",
    "\\iint" : "\u222C",
    "\\iiint" : "\u222D",
    "\\iiiint" : "\u2A0C",
    "\\oint" : "\u222E",
    "\\oiint" : "\u222F",
    "\\oiiint" : "\u2230",
    "\\intclockwise" : "\u2231",
    "\\ointclockwise" : "\u2232",
    "\\ointctrclockwise" : "\u2233",
    "\\sqint" : "\u2A16",
    "\\fint" : "\u2A0F",
    "\\cupint" : "\u2A1A",
    "\\capint" : "\u2A19",
    "\\overbarint" : "\u2A1B",
    "\\underbarint" : "\u2A1C",
    "\\cupplus" : "\u228E",
    "\\timesint" : "\u2A18",
    "\\ast" : "\u2217",
    "\\star" : "\u22C6",
    "\\partial" : "\u2202",
    "\\nabla" : "\u2207",
    "\\sqrt2" : "\u221A",
    "\\sqrt3" : "\u221B",
    "\\sqrt4" : "\u221C",
    "\\circ" : "\u2218",
    "\\sum" : "\u2211",
    "\\osum" : "\u2A0A",
    "\\sumint" : "\u2A0B",
    "\\prod" : "\u220F",
    "\\cdot" : "\u00B7",
    "\\cdotp" : "\u22C5",
    "\\pm" : "\u00B1",
    "\\mp" : "\u2213",
    "\\emptyset" : "\u2205",
    "\\sin" : "sin",
    "\\cos" : "cos",
    "\\tan" : "tan",
    "\\arcsin" : "arcsin",
    "\\arccos" : "arccos",
    "\\arctan" : "arctan",
    "\\cot" : "cot",
    "\\csc" : "csc",
    "\\sec" : "sec",
    "\\arccot" : "arccot",
    "\\arccsc" : "arccsc",
    "\\arcsec" : "arcsec",
    "\\*" : "*",
    "\\det" : "det",
    "\\rank" : "rank",
    "\\log" : "log",
    "\\ln" : "ln",
    "\\lim" : "lim",
    "\\mod" : spacesChar.add+spacesChar.add+"mod"+spacesChar.add,  // 2 spaces + 'mod' + 1 space
    "\\bmod" : spacesChar.add+"mod"+spacesChar.add,  // 1 space + 'mod' + 1 space
    "\\pmod" : pmod,  // 1 space + '(mod' + 1 space + arg + ')'
    "\\cup" : "\u222A",
    "\\Cup" : "\u22D3",
    "\\sqcup" : "\u2294",
    "\\sqCup" : "\u2A4F",
    "\\cap" : "\u2229",
    "\\Cap" : "\u22D2",
    "\\sqcap" : "\u2293",
    "\\sqCap" : "\u2A4E",
    "\\uplus" : "\u228E",
    "\\def" : "\u225D",
    "\\coloneqq" : "\u2254",
    "\\eqqcolon" : "\u2255",
    "\\vee" : "\u2228",
    "\\doublevee" : "\u2A56",
    "\\wedge" : "\u2227",
    "\\doublewedge" : "\u2A55",
    "\\curlyvee" : "\u22CE",
    "\\curlywedge" : "\u22CF",
    "\\diamond" : "\u22C4",
    "\\wr" : "\u2240",
    "\\oplus" : "\u2295",
    "\\ominus" : "\u2296",
    "\\otimes" : "\u2297",
    "\\oslash" : "\u2298",
    "\\odot" : "\u2299",
    "\\obullet" : "\u29BF",
    "\\ocirc" : "\u29BE",
    "\\operp" : "\u29B9",
    "\\oparallel" : "\u29B7",
    "\\oast" : "\u229B",
    "\\oeq" : "\u229C",
    "\\opluslhrim" : "\u2A2D",
    "\\oplusrhrim" : "\u2A2E",
    "\\otimeslhrim" : "\u2A34",
    "\\otimesrhrim" : "\u2A35",
    "\\boxplus" : "\u229E",
    "\\boxminus" : "\u229F",
    "\\boxtimes" : "\u22A0",
    "\\boxdot" : "\u22A1",
    "\\amalg" : "\u2210",
    "\\tprime" : "\u2034",
    "\\lthree" : "\u22CB",
    "\\rthree" : "\u22CC",
    "\\pitchfork" : "\u22D4",
    "\\topfork" : "\u2ADA",
    "\\invamp" : "\u214B",
    "\\originalof" : "\u22B6",
    "\\imageof" : "\u22B7",
    "\\multimap" : "\u22B8",
    "\\leftmultimap" : "\u27DC",
    "\\uptack" : "\u27DF",
    "\\xor" : "\u22BB",
    "\\nand" : "\u22BC",
    "\\nor" : "\u22BD",
    "\\divideontimes" : "\u22C7",
    "\\smashtimes" : "\u2A33",
    "\\fracline" : "\u2215",  // Better suited for superscript over subscript

    // Relations
    "\\forall" : "\u2200",
    "\\exists" : "\u2203",
    "\\nexists" : "\u2204",
    "\\land" : "\u2227",
    "\\lor" : "\u2228",
    "\\sqland" : "\u27CE",
    "\\sqlor" : "\u27CF",
    "\\in" : "\u2208",
    "\\notin" : "\u2209",
    "\\ni" : "\u220B",
    "\\subset" : "\u2282",
    "\\nsubset" : "\u2284",
    "\\subseteq" : "\u2286",
    "\\nsubseteq" : "\u2288",
    "\\supset" : "\u2283",
    "\\nsupset" : "\u2285",
    "\\supseteq" : "\u2287",
    "\\nsupseteq" : "\u2289",
    "\\sqsubset" : "\u228F",
    "\\sqsupset" : "\u2290",
    "\\sqsubseteq" : "\u2291",
    "\\sqsupseteq" : "\u2292",
    "\\Subset" : "\u22D0",
    "\\Supset" : "\u22D1",
    "\\subsetplus" : "\u2ABF",
    "\\supsetplus" : "\u2AC0",
    "\\osubset" : "\u27C3",
    "\\osupset" : "\u27C4",
    "\\setminus" : "\u2216",
    "\\cong" : "\u2245",
    "\\ncong" : "\u2247",
    "\\propto" : "\u221D",
    "\\equiv" : "\u2261",
    "\\dotequiv" : "\u2A67",
    "\\superequiv" : "\u2263",
    "\\tbond" : "\u2261",
    "\\qbond" : "\u2263",
    "\\doteq" : "\u2250",
    "\\eqdot" : "\u2A66",
    "\\neq" : "\u2260",
    "\\approx" : "\u2248",
    "\\sim" : "\u223C",
    "\\simeq" : "\u224C",
    "\\nsim" : "\u2241",
    "\\nless" : "\u226E",
    "\\ngtr" : "\u226F",
    "\\leq" : "\u2264",
    "\\leqslant" : "\u2A7D",
    "\\geq" : "\u2265",
    "\\geqslant" : "\u2A7E",
    "\\nleq" : "\u2270",
    "\\ngeq" : "\u2271",
    "\\lneq" : "\u2A87",
    "\\lneqq" : "\u2268",
    "\\gneq" : "\u2A88",
    "\\gneqq" : "\u2269",
    "\\lnapprox" : "\u2A89",
    "\\gnapprox" : "\u2A8A",
    "\\lnsim" : "\u22E6",
    "\\gnsim" : "\u22E7",
    "\\ll" : "\u226A",
    "\\lll" : "\u22D8",
    "\\gg" : "\u226B",
    "\\ggg" : "\u22D9",
    "\\prec" : "\u227A",
    "\\succ" : "\u227B",
    "\\nprec" : "\u2280",
    "\\nsucc" : "\u2281",
    "\\preceq" : "\u227C",
    "\\succeq" : "\u227D",
    "\\precneqq" : "\u2AB5",
    "\\succneqq" : "\u2AB6",
    "\\precnapprox" : "\u2AB9",
    "\\succnapprox" : "\u2ABA",
    "\\precnsim" : "\u22E8",
    "\\succnsim" : "\u22E9",
    "\\perp" : "\u27C2",
    "\\Perp" : "\u2AEB",
    "\\parallel" : "\u2225",
    "\\nparallel" : "\u2226",
    "\\vvvert" : "\u2AF4",
    "\\nvvvert" : "\u2AF5",
    "\\mid" : "|",
    "\\nmid" : "\u2224",
    "\\asymp" : "\u224D",
    "\\neg" : "\u00AC",
    "\\bowtie" : "\u2A1D",
    "\\vdash" : "\u22A2",
    "\\nvdash" : "\u22AC",
    "\\dashv" : "\u22A3",
    "\\vDash" : "\u22A8",
    "\\Dashv" : "\u2AE4",
    "\\nvDash" : "\u22AD",
    "\\Vdash" : "\u22A9",
    "\\dashV" : "\u2AE3",
    "\\nVdash" : "\u22AE",
    "\\VDash" : "\u22AB",
    "\\DashV" : "\u2AE5",
    "\\nVDash" : "\u22AF",
    "\\triangleleft" : "\u22B2",
    "\\ntriangleleft" : "\u22EA",
    "\\triangleright" : "\u22B3",
    "\\ntriangleright" : "\u22EB",
    "\\ntrianglelefteq" : "\u22EC",
    "\\ntrianglerighteq" : "\u22ED",
    "\\trianglelefteq" : "\u22B4",
    "\\trianglerighteq" : "\u22B5",
    "\\triangleq" : "\u225C",
    "\\equest" : "\u225F",
    "\\lquest" : "\u2A7B",
    "\\rquest" : "\u2A7C",
    "\\mquest" : "\u225E",
    "\\vdots" : "\u22EE",
    "\\cdots" : "\u22EF",
    "\\udots" : "\u22F0",
    "\\ddots" : "\u22F1",
    "\\ldots" : "\u2026",
    "\\top" : "\u22A4",
    "\\bot" : "\u22A5",
    "\\between" : "\u226C",
    "\\therefore" : "\u2234",
    "\\because" : "\u2235",
    "\\squaredots" : "\u2237",
    "\\dotminus" : "\u2238",
    "\\max" : "max",
    "\\min" : "min",
    "\\grad" : "grad",
    "\\curl" : "curl",
    "\\ratio" : "\u2236",  // Same as ":", except with "!chem"

    // Arrows
    "\\Rightarrow" : "\u21D2",
    "\\Leftarrow" : "\u21D0",
    "\\nLeftarrow" : "\u21CD",
    "\\nRightarrow" : "\u21CF",
    "\\nLeftrightarrow" : "\u21CE",
    "\\Uparrow" : "\u21D1",
    "\\Downarrow" : "\u21D3",
    "\\Updownarrow" : "\u21D5",
    "\\rightarrow" : "\u2192",
    "\\to" : "\u2192",
    "\\longrightarrow" : "\u27F6",
    "\\leftarrow" : "\u2190",
    "\\longleftarrow" : "\u27F5",
    "\\leftrightarrow" : "\u2194",
    "\\nleftrightarrow" : "\u21AE",
    "\\uparrow" : "\u2191",
    "\\downarrow" : "\u2193",
    "\\updownarrow" : "\u2195",
    "\\nleftarrow" : "\u219A",
    "\\nrightarrow" : "\u219B",
    "\\Longleftarrow" : "\u27F8",
    "\\implies" : "\u27F9",
    "\\Longrightarrow" : "\u27F9",
    "\\Leftrightarrow" : "\u21D4",
    "\\iff" : "\u27FA",
    "\\mapsto" : "\u27FC",
    "\\rightleftharpoons" : "\u21CC",
    "\\leftrightharpoons" : "\u21CB",
    "\\rightharpoonup" : "\u21C0",
    "\\rightharpoondown" : "\u21C1",
    "\\leftharpoonup" : "\u21BC",
    "\\leftharpoondown" : "\u21BD",
    "\\upharpoonleft" : "\u21BF",
    "\\upharpoonright" : "\u21BE",
    "\\downharpoonleft" : "\u21C3",
    "\\downharpoonright" : "\u21C2", 
    "\\hookleftarrow" : "\u21A9",
    "\\hookrightarrow" : "\u21AA",
    "\\nearrow" : "\u2197",
    "\\searrow" : "\u2198",
    "\\swarrow" : "\u2199",
    "\\nwarrow" : "\u2196",
    "\\Nearrow" : "\u21D7",
    "\\Searrow" : "\u21D8",
    "\\Swarrow" : "\u21D9",
    "\\Nwarrow" : "\u21D6",
    "\\twoheadleftarrow" : "\u219E",
    "\\twoheadrightarrow" : "\u21A0",
    "\\twoheaduparrow" : "\u219F",
    "\\twoheaddownarrow" : "\u21A1",
    "\\Lsh" : "\u21B0",
    "\\Rsh" : "\u21B1",
    "\\leftleftarrows" : "\u21C7",
    "\\rightrightarrows" : "\u21C9",
    "\\rightrightrightarrows" : "\u21F6",
    "\\upuparrows" : "\u21C8",
    "\\downdownarrows" : "\u21CA",
    "\\leftrightarrows" : "\u21C6",
    "\\rightleftarrows" : "\u21C4",
    "\\Lleftarrow" : "\u21DA",
    "\\Rrightarrow" : "\u21DB",
    "\\Uuparrow" : "\u290A",
    "\\Ddownarrow" : "\u290B",
    "\\leftarrowtail" : "\u21A2",
    "\\rightarrowtail" : "\u21A3",
    "\\leftsquigarrow" : "\u21DC",
    "\\rightsquigarrow" : "\u21DD",
    "\\leftrightsquigarrow" : "\u21AD",
    "\\longrightsquiglearrow" : "\u27FF",
    "\\looparrowleft" : "\u21AB",
    "\\looparrowright" : "\u21AC",
    "\\circlearrowleft" : "\u21BA",
    "\\circlearrowright" : "\u21BB",
    "\\curvearrowleft" : "\u21B6",
    "\\curvearrowright" : "\u21B7",
    "\\leftdasharrow" : "\u21E0",
    "\\rightdasharrow" : "\u21E2",
    "\\updasharrow" : "\u21E1",
    "\\downdasharrow" : "\u21E3",
    "\\tildeabovearrow" : "\u2972",
    "\\tildebelowarrow" : "\u2974",
    "\\equalabovearrow" : "\u2971",

    // Hebrew alphabet
    "\\aleph" : "\u2135",
    "\\beth" : "\u2136",
    "\\gimel" : "\u2137",
    "\\dalet" : "\u2138",

    // Convert text
    "\\mathbb" : mathbb,
    "\\mathbf" : mathbf,
    "\\mathcal" : mathcal,
    "\\mathfrak" : mathfrak,
    "^" : superscript,
    "_" : subscript,
    "\\mathrm" : text,
    "\\text" : text,
    "\\textbf" : textbf,
    "\\textit" : textit,
    "\\texttt" : texttt,

    // Spaces
    "\\hspace" : hspace,
    "\\vskip" : vskip,
    "\\phantom" : phantom,
    "\\mathord" : mathord,

    // Square root and fractions
    "\\sqrt" : sqrt,
    "\\frac" : frac,
    "\\frac*" : singleCharFrac,

    // Combining symbols
    "\\overline" : overline,
    "\\underline" : underline,
    "\\underarrow" : underarrow,
    "\\underharpoon" : underharpoon,
    "\\overfrown" : overfrown,
    "\\oversmile" : oversmile,
    "\\undersmile" : undersmile,
    "\\hat" : hat,
    "\\not" : not,
    "\\tilde" : tilde,
    "\\vec" : vec,
    "\\hvec" : hvec,
    "\\dot" : dot,
    "\\ddot" : ddot,
    "\\acute" : acute,
    "\\grave" : grave,
    "\\stackrel" : stackrel,
    "\\overset" : overset,
    "\\underset" : underset,
    "\\check" : caron,
    "\\breve" : breve,
    "\\bar" : bar,

    // For Lewis Notation
    "\\mdot" : "\u2E31",
    "\\mddot" : "\u003A",

    // Chess
    "\\wking" : "\u2654",
    "\\wqueen" : "\u2655",
    "\\wrook" : "\u2656",
    "\\wbishop" : "\u2657",
    "\\wknight" :"\u2658",
    "\\wpawn" : "\u2659",
    "\\bking" : "\u265A",
    "\\bqueen" : "\u265B",
    "\\brook" : "\u265C",
    "\\bbishop" : "\u265D",
    "\\bknight" :"\u265E",
    "\\bpawn" : "\u265F",

    // Card games
    "\\bspade" : "\u2660",
    "\\wheart" : "\u2661",
    "\\wdiamond" : "\u2662",
    "\\bclub" : "\u2663",
    "\\wspade" : "\u2664",
    "\\bheart" : "\u2665",
    "\\bdiamond" : "\u2666",
    "\\wclub" : "\u2667",

    // Money
    "\\dollar" : "\u0024",
    "\\cent" : "\u00A2",
    "\\pound" : "\u00A3",
    "\\yen" : "\u00A5",
    "\\franc" : "\u20A3",
    "\\euro" : "\u20AC",
    "\\peso" : "\u20B1",
    "\\bitcoin" : "\u20BF",
    "\\austral" : "\u20B3",
    "\\ruble" : "\u20BD",
    "\\hryvnia" : "\u20B4",
    "\\rupee" : "\u20B9",
    "\\lira" : "\u20AA",
    "\\tlira" : "\u20A9",
    "\\won" : "\u20A9",
    "\\baht" : "\u0E3F",

    // Non italic letters
    "\\A" : "A",
    "\\a" : "a",
    "\\B" : "B",
    "\\b" : "b",
    "\\C" : "C",
    "\\c" : "c",
    "\\D" : "D",
    "\\d" : "d",
    "\\E" : "E",
    "\\e" : "e",
    "\\F" : "F",
    "\\f" : "f",
    "\\G" : "G",
    "\\g" : "g",
    "\\H" : "H",
    "\\h" : "h",
    "\\I" : "I",
    "\\i" : "i",
    "\\J" : "J",
    "\\j" : "j",
    "\\K" : "K",
    "\\k" : "k",
    "\\L" : "L",
    "\\l" : "l",
    "\\M" : "M",
    "\\m" : "m",
    "\\N" : "N",
    "\\n" : "n",
    "\\O" : "O",
    "\\o" : "o",
    "\\P" : "P",
    "\\p" : "p",
    "\\Q" : "Q",
    "\\q" : "q",
    "\\R" : "R",
    "\\r" : "r",
    "\\S" : "S",
    "\\s" : "s",
    "\\T" : "T",
    "\\t" : "t",
    "\\U" : "U",
    "\\u" : "u",
    "\\V" : "V",
    "\\v" : "v",
    "\\W" : "W",
    "\\w" : "w",
    "\\X" : "X",
    "\\x" : "x",
    "\\Y" : "Y",
    "\\y" : "y",
    "\\Z" : "Z",
    "\\z" : "z",

    "\\^" : "^",
    "\\_" : "_",

    // Matrix
    "\\matrix" : matrix,
    "\\id1" : "["+spacesChar.add+"1"+spacesChar.add+"]",
    "\\id2" : "\u23A1"+spacesChar.add+"1"+spacesChar.add+"0"+spacesChar.add+"\u23A4 \u000A \u23A3 "+
              spacesChar.add+"0"+spacesChar.add+"1"+spacesChar.add+"\u23A6",
    "\\id3" : "\u23A1"+spacesChar.add+"1"+spacesChar.add+""+spacesChar.add+"0"+spacesChar.add+"\u23A4 \u000A \u23A2"+
              spacesChar.add+"0"+spacesChar.add+"1"+spacesChar.add+"0"+spacesChar.add+"\u23A5 \u000A \u23A3"+
              spacesChar.add+"0"+spacesChar.add+"0"+spacesChar.add+"1"+spacesChar.add+"\u23A6",
    "\\id4" : "\u23A1"+spacesChar.add+"1"+spacesChar.add+"0"+spacesChar.add+"0"+spacesChar.add+"0"+spacesChar.add+"\u23A4 \u000A \u23A2"+
              spacesChar.add+"0"+spacesChar.add+"1"+spacesChar.add+"0"+spacesChar.add+"0"+spacesChar.add+"\u23A5 \u000A \u23A2"+spacesChar.add+
              "0"+spacesChar.add+"0"+spacesChar.add+"1"+spacesChar.add+"0"+spacesChar.add+"\u23A5 \u000A \u23A3"+spacesChar.add+"0"+spacesChar.add+
              "0"+spacesChar.add+"0"+spacesChar.add+"1"+spacesChar.add+"\u23A6",
    "\\idn" : "\u23A1"+spacesChar.add+"1"+spacesChar.add+"0"+spacesChar.add+"\u22EF"+spacesChar.add+"0"+spacesChar.add+"\u23A4 \u000A \u23A2"+spacesChar.add+
              "0"+spacesChar.add+"1"+spacesChar.add+"\u22EF"+spacesChar.add+"0"+spacesChar.add+"\u23A5 \u000A \u23A2"+spacesChar.add+spacesChar.add+"\u22EE"+
              spacesChar.add+spacesChar.add+"\u22EE"+spacesChar.add+spacesChar.add+"\u22F1"+spacesChar.add+spacesChar.add+"\u22EE"+spacesChar.add+
              "\u23A5 \u000A \u23A3"+spacesChar.add+"0"+spacesChar.add+"0"+spacesChar.add+"\u22EF"+spacesChar.add+"1"+spacesChar.add+"\u23A6",
    // To build your own
    "\\mlceil" : "\u23A1",
    "\\mrceil" : "\u23A4",
    "\\mlmid" : "\u23A2",
    "\\mrmid" : "\u23A5",
    "\\mlfloor" : "\u23A3",
    "\\mrfloor" : "\u23A6",

    // Music
    "\\flat" : "\u{1D12C}",
    "\\natural" : "\u{1D12E}",
    "\\sharp" : "\u{1D130}",
    "\\eightnote" : "\u{1D160}",
    "\\sixteenthnote" : "\u{1D161}",
    "\\halfnote" : "\u{1D15E}",
    "\\quarternote" : "\u{1D15F}",
    "\\fullnote" : "\u{1D15D}",
    "\\doublenote" : "\u266B",
    "\\trebleclef" : "\u{1D11E}",
    
    // Box drawing
    "\\boxh" : "\u2500",
    "\\boxbfh" : "\u2501",
    "\\boxH" : "\u2550",
    "\\boxv" : "\u2502",
    "\\boxbfv" : "\u2503",
    "\\boxV" : "\u2551",
    "\\boxdr" : "\u250C",
    "\\boxbfdr" : "\u250F",
    "\\boxDR" : "\u2554",
    "\\boxdl" : "\u2510",
    "\\boxbfdl" : "\u2513",
    "\\boxDL" : "\u2557",
    "\\boxur" : "\u2514",
    "\\boxbfur" : "\u2517",
    "\\boxUR" : "\u255A",
    "\\boxul" : "\u2518",
    "\\boxbful" : "\u251B",
    "\\boxUL" : "\u255D",
    "\\boxvr" : "\u251C",
    "\\boxbfvr" : "\u2523",
    "\\boxVR" : "\u2560",
    "\\boxvl" : "\u2524",
    "\\boxbfvl" : "\u252B",
    "\\boxVL" : "\u2563",
    "\\boxdh" : "\u252C",
    "\\boxbfdh" : "\u2533",
    "\\boxDH" : "\u2566",
    "\\boxuh" : "\u2534",
    "\\boxbfuh" : "\u253B",
    "\\boxUH" : "\u2569",
    "\\boxvh" : "\u253C",
    "\\boxbfvh" : "\u254B",
    "\\boxVH" : "\u256C",

    // Other symbols
    "\\LaTeX" : "ğ¿á´¬ğ‘‡á´‡ğ‘‹",
    "\\TeX" : "ğ‘‡á´‡ğ‘‹",
    "\\MatTalX" : "ğ‘€á´€á´›ğ‘‡á´€ÊŸğ‘‹",
    "\\CaMuS" : "ğ¶á´¬ğ‘€á´œğ‘†",  // https://camus.espaceweb.usherbrooke.ca/index.html
    "\\infty" : "\u221E",
    "\\iinfin" : "\u29DC",
    "\\tieinfty" : "\u29DD",
    "\\nvinfty" : "\u29DE",
    "\\acidfree" : "\u267E",
    "\\radioactive" : "\u2622",
    "\\biohazard" : "\u2623",
    "\\atom" : "\u269B",
    "\\permil" : "â€°",
    "\\textperthousand" : "â€°",  // Weird command name, but trying to respect LaTeX's nomenclature
    "\\perthousand" : "â€±",
    "\\angle" : "\u2220",
    "\\measuredangle" : "\u2221",
    "\\sphericalangle" : "\u2222",
    "\\rightangle" : "\u299C",
    "\\hbar" : "\u210F",
    "\\ell" : "\u2113",
    "\\dagger" : "\u2020",
    "\\ddagger" : "\u2021",
    "\\dddagger" : "\u2E4B",
    "\\hermitian" : "\u22B9",
    "\\qc" : "\u269C",
    "\\section" : "\u00A7",
    "\\paragraph" : "\u00B6",
    "\\copyright" : "\u00A9",
    "\\registered" : "\u00AE",
    "\\wp" : "\u2118",
    "\\laplace" : "\u2112",
    "\\bloch" : "\u212C",
    "\\im" : "\u2111",
    "\\fourier" : "\u2131",
    "\\angstrom" : "\u212B",
    "\\mho" : "\u2127",
    "\\emdash" : "\u2014",
    "\\bullet" : "\u2219",
    "\\textbullet" : "\u2022",
    "\\bigbullet" : "\u25CF",
    "\\langle" : "\u27E8",
    "\\rangle" : "\u27E9",
    "\\llangle" : "\u27EA",
    "\\rrangle" : "\u27EB",
    "\\lceil" : "\u2308",
    "\\rceil" : "\u2309",
    "\\lfloor" : "\u230A",
    "\\rfloor" : "\u230B",
    "\\lBrace" : "\u2983",
    "\\rBrace" : "\u2984",
    "\\%" : "%",
    "\\{" : "{",
    "\\}" : "}",
    "\\(" : "(",
    "\\)" : ")",
    "\\$" : "$",
    "\\backslash" : "\\",
    "\\llbracket" : "\u27E6",
    "\\rrbracket" : "\u27E7",
    "\\llparenthesis" : "\u2985",
    "\\rrparenthesis" : "\u2986",
    "\\frown" : "\u2322",
    "\\smile" : "\u2323",
    "\\qed" : "\u220E",
    "\\blacksquare" : "\u25A0",
    "\\square" : "\u25A1",
    "\\lightning" : "\u21AF",
    "\\dbend" : "\u2621",
    "\\male" : "\u2642",
    "\\female" : "\u2640",
    "\\Hermaphrodite" : "\u26A5",
    "\\neuter" : "\u26B2",
    "\\malemale" : "\u26A3",
    "\\femalefemale" : "\u26A2",
    "\\femalemale" : "\u26A4",
    "\\" : "\\",
    "\\:" : spacesChar.add,
    "\\;" : spacesChar.add+spacesChar.add,
    "\\quad" : spacesChar.add+spacesChar.add+spacesChar.add,
    "\\qquad" : spacesChar.add+spacesChar.add+spacesChar.add+spacesChar.add,
    "\\!" : spacesChar.remove,
    "\\colon" : "\u003A",
    "\\\\" : "\u000A",
    "\\linebreak" : "\u000A",
    "\\newline" : "\u000A",
    "\\tab" : "\u0009"
};

// Standard dict for greek letters
const stdGreek = {
    "\\Alpha" : "\u{1D6E2}",
    "\\alpha" : "\u{1D6FC}",
    "\\Beta" : "\u{1D6E3}",
    "\\beta" : "\u{1D6FD}",
    "\\Gamma" : "\u{1D6E4}",
    "\\gamma" : "\u{1D6FE}",
    "\\Delta" : "\u0394",
    "\\varDelta" : "\u{1D6E5}",
    "\\delta" : "\u{1D6FF}",
    "\\Epsilon" : "\u{1D6E6}",
    "\\epsilon" : "\u03F5",
    "\\varepsilon" : "\u03B5",
    "\\Zeta" : "\u{1D6E7}",
    "\\zeta" : "\u{1D701}",
    "\\Eta" : "\u{1D6E8}",
    "\\eta" : "\u{1D702}",
    "\\Theta" : "\u0398",
    "\\theta" : "\u{1D703}",
    "\\vartheta" : "\u{1D717}",
    "\\Iota" : "\u{1D6EA}",
    "\\iota" : "\u{1D704}",
    "\\Kappa" : "\u{1D6EB}",
    "\\kappa" : "\u{1D705}",
    "\\varkappa" : "\u{1D718}",
    "\\Lambda" : "\u{1D6EC}",
    "\\lambda" : "\u{1D706}",
    "\\Mu" : "\u{1D6ED}",
    "\\mu" : "\u{1D707}",
    "\\Nu" : "\u{1D6EE}",
    "\\nu" : "\u{1D708}",
    "\\Xi" : "\u039E",
    "\\xi" : "\u{1D709}",
    "\\Omicron" : "\u{1D6F0}",
    "\\omicron" : "\u{1D70A}",
    "\\Pi" : "\u{1D6F1}",
    "\\pi" : "\u{1D70B}",
    "\\varpi" : "\u{1D71B}",
    "\\Rho" : "\u{1D6F2}",
    "\\rho" : "\u{1D70C}",
    "\\varrho" : "\u{1D71A}",
    "\\Sigma" : "\u{1D6F4}",
    "\\sigma" : "\u{1D70E}",
    "\\varsigma" : "\u{1D70D}",
    "\\Tau" : "\u{1D6F5}",
    "\\tau" : "\u{1D70F}",
    "\\Upsilon" : "\u{1D6F6}",
    "\\upsilon" : "\u{1D710}",
    "\\Phi" : "\u03A6",
    "\\phi" : "\u{1D719}",
    "\\varphi" : "\u{1D711}",
    "\\Chi" : "\u{1D6F8}",
    "\\chi" : "\u{1D712}",
    "\\Psi" : "\u{1D6F9}",
    "\\psi" : "\u{1D713}",
    "\\Omega" : "\u2126",
    "\\omega" : "\u{1D714}"
};

// Greek letters if the user wants basic UTF-8 characters (nostyle)
const noStyleGreek = {
    "\\Alpha" : "\u0391",
    "\\alpha" : "\u03B1",
    "\\Beta" : "\u0392",
    "\\beta" : "\u03B2",
    "\\Gamma" : "\u0393",
    "\\gamma" : "\u03B3",
    "\\Delta" : "\u0394",
    "\\varDelta" : "\u{1D6E5}",
    "\\delta" : "\u03B4",
    "\\Epsilon" : "\u0395",
    "\\epsilon" : "\u03F5",
    "\\varepsilon" : "\u03B5",
    "\\Zeta" : "\u0396",
    "\\zeta" : "\u03B6",
    "\\Eta" : "\u0397",
    "\\eta" : "\u03B7",
    "\\Theta" : "\u0398",
    "\\theta" : "\u03B8",
    "\\vartheta" : "\u03D1",
    "\\Iota" : "\u0399",
    "\\iota" : "\u03B9",
    "\\Kappa" : "\u039A",
    "\\kappa" : "\u03BA",
    "\\varkappa" : "\u03F0",
    "\\Lambda" : "\u039B",
    "\\lambda" : "\u03BB",
    "\\Mu" : "\u039C",
    "\\mu" : "\u03BC",
    "\\Nu" : "\u039D",
    "\\nu" : "\u03BD",
    "\\Xi" : "\u039E",
    "\\xi" : "\u03BE",
    "\\Omicron" : "\u039F",
    "\\omicron" : "\u03BF",
    "\\Pi" : "\u03A0",
    "\\pi" : "\u03C0",
    "\\varpi" : "\u03D6",
    "\\Rho" : "\u03A1",
    "\\rho" : "\u03C1",
    "\\varrho" : "\u03F1",
    "\\Sigma" : "\u03A3",
    "\\sigma" : "\u03C3",
    "\\varsigma" : "\u03C2",
    "\\Tau" : "\u03A4",
    "\\tau" : "\u03C4",
    "\\Upsilon" : "\u03A5",
    "\\upsilon" : "\u03C5",
    "\\Phi" : "\u03A6",
    "\\phi" : "\u03D5",
    "\\varphi" : "\u03C6",
    "\\Chi" : "\u03A7",
    "\\chi" : "\u03C7",
    "\\Psi" : "\u03A8",
    "\\psi" : "\u03C8",
    "\\Omega" : "\u03A9",
    "\\omega" : "\u03C9"
};

// Default dict (in math mode), used in the completion popup
const defaultDict = {...mathDictionary, ...stdGreek};

const textCommands = {
    "\\LaTeX" : "ğ¿á´¬ğ‘‡á´‡ğ‘‹",
    "\\TeX" : "ğ‘‡á´‡ğ‘‹",
    "\\MatTalX" : "ğ‘€á´€á´›ğ‘‡á´€ÊŸğ‘‹",
    "\\CaMuS" : "ğ¶á´¬ğ‘€á´œğ‘†",  // https://camus.espaceweb.usherbrooke.ca/index.html
    "\\textbullet" : "\u2022",
    "\\section" : "\u00A7",
    "\\paragraph" : "\u00B6",
    "\\copyright" : "\u00A9",
    "\\registered" : "\u00AE",
    "\\%" : "%",
    "\\#" : "#",
    "\\{" : "{",
    "\\}" : "}",
    "\\$" : "$",
    "\\backslash" : "\\",
    "\\textbackslash" : "\\",
    "\\\\" : "\u000A",
    "\\linebreak" : "\u000A",
    "\\newline" : "\u000A",
    "\\tab" : "\u0009",
    "\\!" : spacesChar.remove,
    "\\O" : "\u00D8",
    "\\o" : "\u00F8",
    "\\i" : "\u0131",
    "\\j" : "\u0237",
    "\\L" : "\u0141",
    "\\l" : "\u0142",
    "\\OE" : "\u0152",
    "\\oe" : "\u0153",
    "\\AE" : "\u00C6",
    "\\ae" : "\u00E6",
    "\\textbf" : textbf,
    "\\textit" : textit,
    "\\texttt" : texttt,
    "\\hspace" : hspace,
    "\\vskip" : vskip,
    "\\`" : grave,
    "\\'" : acute,
    "\\^" : hat,
    '\\"' : ddot,
    "\\H" : doubleAccute,
    "\\~" : tilde,
    "\\c" : cedilla,
    "\\k" : ogonek,
    "\\=" : bar,
    "\\b" : underline,
    "\\." : dot,
    "\\d" : dotBelow,
    "\\r" : ringAbove,
    "\\u" : breve,
    "\\v" : caron,
    "\\today" : today()
};

// Superscript is used (by the superscript function) to convert characters to the corresponding superscript character
const Superscript = {
    "0" : "\u2070",
    "1" : "\u00B9",
    "2" : "\u00B2",
    "3" : "\u00B3",
    "4" : "\u2074",
    "5" : "\u2075",
    "6" : "\u2076",
    "7" : "\u2077",
    "8" : "\u2078",
    "9" : "\u2079",

    "+" : "\u207A",
    "-" : "\u207B",
    "\u2212" : "\u207B",
    "=" : "\u207C",
    "â‰ " : "á™¿",
    "(" : "\u207D",
    ")" : "\u207E",
    "\\" : "á ",
    "âˆ–" : "á ",
    "/" : "áŸ",
    "." : "á§",
    "," : "\u02D2",
    "!" : "êœ",
    "$" : "á™š",
    "âŸ‚" : "á—®",
    "Ã—" : "á•",
    "âˆ«" : "á¶´",
    "âˆ˜" : "Â°",
    "âˆ" : spacesChar.add+"\u1AB2"+spacesChar.add,  // Only works on certain website/apps
    "âˆ…" : "\u{1D1A9}",
    "*" : "*",
    "<" : "á‘‰",
    "âˆ¥" : "á¦",
    "âŠ‚" : "á’¼",
    "âŠƒ" : "á£",
    "âˆª" : "á¡",
    "âˆ©" : "á¢",
    "âˆ¨" : "á˜",
    "âˆ§" : "á¶º",
    "âŒŠ" : "á’»",
    "âŒ‹" : "á’½",
    "â„§" : "á¶·",
    "â†‘" : "êœ›",
    "â†“" : "êœœ",
    "Å’" : "ğ£",
    "Å“" : "êŸ¹",
    "Ã¦" : "ğƒ",

    "A" : "á´¬",
    "a" : "áµƒ",
    "B" : "á´®",
    "b" : "áµ‡",
    "C" : "á¶œ",
    "c" : "á¶œ",
    "D" : "á´°",
    "d" : "áµˆ",
    "E" : "á´±",
    "e" : "áµ‰",
    "f" : "á¶ ",
    "G" : "á´³",
    "g" : "áµ",
    "H" : "á´´",
    "h" : "Ê°",
    "I" : "á´µ",
    "i" : "â±",
    "J" : "á´¶",
    "j" : "Ê²",
    "K" : "á´·",
    "k" : "áµ",
    "L" : "á´¸",
    "l" : "Ë¡",
    "M" : "á´¹",
    "m" : "áµ",
    "N" : "á´º",
    "n" : "â¿",
    "O" : "á´¼",
    "o" : "áµ’",
    "P" : "á´¾",
    "p" : "áµ–",
    "R" : "á´¿",
    "r" : "Ê³",
    "S" : "Ë¢",
    "s" : "Ë¢",
    "T" : "áµ€",
    "t" : "áµ—",
    "U" : "áµ",
    "u" : "áµ˜",
    "V" : "â±½",
    "v" : "áµ›",
    "W" : "áµ‚",
    "w" : "Ê·",
    "X" : "Ë£",
    "x" : "Ë£",
    "y" : "Ê¸",
    "Z" : "á™†",
    "z" : "á¶»",

    "ğ´" : "á´¬",
    "ğ‘" : "áµƒ",
    "ğµ" : "á´®",
    "ğ‘" : "áµ‡",
    "ğ¶" : "á¶œ",
    "ğ‘" : "á¶œ",
    "ğ·" : "á´°",
    "ğ‘‘" : "áµˆ",
    "ğ¸" : "á´±",
    "ğ‘’" : "áµ‰",
    "ğ‘“" : "á¶ ",
    "ğº" : "á´³",
    "ğ‘”" : "áµ",
    "ğ»" : "á´´",
    "â„" : "Ê°",
    "ğ¼" : "á´µ",
    "ğ‘–" : "â±",
    "ğ½" : "á´¶",
    "ğ‘—" : "Ê²",
    "ğ¾" : "á´·",
    "ğ‘˜" : "áµ",
    "ğ¿" : "á´¸",
    "ğ‘™" : "Ë¡",
    "ğ‘€" : "á´¹",
    "ğ‘š" : "áµ",
    "ğ‘" : "á´º",
    "ğ‘›" : "â¿",
    "ğ‘‚" : "á´¼",
    "ğ‘œ" : "áµ’",
    "ğ‘ƒ" : "á´¾",
    "ğ‘" : "áµ–",
    "ğ‘…" : "á´¿",
    "ğ‘Ÿ" : "Ê³",
    "ğ‘†" : "Ë¢",
    "ğ‘ " : "Ë¢",
    "ğ‘‡" : "áµ€",
    "ğ‘¡" : "áµ—",
    "ğ‘ˆ" : "áµ",
    "ğ‘¢" : "áµ˜",
    "ğ‘‰" : "â±½",
    "ğ‘£" : "áµ›",
    "ğ‘Š" : "áµ‚",
    "ğ‘¤" : "Ê·",
    "ğ‘‹" : "Ë£",
    "ğ‘¥" : "Ë£",
    "ğ‘¦" : "Ê¸",
    "ğ‘" : "á¶»",
    "ğ‘§" : "á¶»",

    "ğ›½" : "\u1D5D",
    "Î²" : "\u1D5D", 
    "ğ›¤" : "á£˜",
    "Î“" : "á£˜",
    "ğ›¾" : "\u1D5E",
    "Î³" : "\u1D5E",
    "Î”" : "á",
    "Î´" : "\u1D5F",
    "ğ›¿" : "\u1D5F",
    "Ïµ" : "áµ‹",
    "Îµ" : "áµ‹",
    "ğ›¬" : "á£”",
    "Î›" : "á£”",
    "ğœƒ" : "\u1DBF",
    "Î¸" : "\u1DBF", 
    "ğœ„" : "á¶¥",
    "Î¹" : "á¶¥",
    "ğœˆ" : "á¶¹",
    "Î½" : "á¶¹",
    "ğœ" : "á£™",
    "Ïƒ" : "á£™",
    "Î¦" : "á¶²",
    "ğœ™" : "á¶²",
    "Ï•" : "á¶²",
    "ğœ‘" : "\u1D60",
    "Ï†" : "\u1D60",
    "ğœŒ" : "á£–",
    "Ï" : "á£–",
    "ğœ’" : "\u1D61",
    "Ï‡" : "\u1D61",

    "\u2710" : spacesChar.add,
    "\u270E" : spacesChar.remove,
    " " : " ",
    "\u000A" : "\u000A",
    "" : ""
};

// Subscript is used (by the subscript function) to convert characters to the corresponding subscript character
const Subscript = {
    "0" : "\u2080",
    "1" : "\u2081",
    "2" : "\u2082",
    "3" : "\u2083",
    "4" : "\u2084",
    "5" : "\u2085",
    "6" : "\u2086",
    "7" : "\u2087",
    "8" : "\u2088",
    "9" : "\u2089",

    "+" : "\u208A",
    "-" : "\u208B",
    "\u2212" : "\u208B",
    "=" : "\u208C",
    "(" : "\u208D",
    ")" : "\u208E",
    "," : spacesChar.add+"\u0326"+spacesChar.add,
    "." : spacesChar.add+"\u0323"+spacesChar.add,
    "Ã—" : "á™®",

    "a" : "\u2090",
    "e" : "\u2091",
    "h" : "\u2095",
    "i" : "\u1D62",
    "j" : "â±¼",
    "k" : "\u2096",
    "l" : "\u2097",
    "m" : "\u2098",
    "n" : "\u2099",
    "O" : "\u2092",
    "o" : "\u2092",
    "p" : "\u209A",
    "r" : "áµ£",
    "S" : "\u209B",
    "s" : "\u209B",
    "t" : "\u209C",
    "u" : "áµ¤",
    "V" : "áµ¥",
    "v" : "áµ¥",
    "X" : "\u2093",
    "x" : "\u2093",

    "ğ‘" : "\u2090",
    "ğ‘’" : "\u2091",
    "â„" : "\u2095",
    "ğ‘–" : "\u1D62",
    "ğ‘—" : "â±¼",
    "ğ‘˜" : "\u2096",
    "ğ‘™" : "\u2097",
    "ğ‘š" : "\u2098",
    "ğ‘›" : "\u2099",
    "ğ‘‚" : "\u2092",
    "ğ‘œ" : "\u2092",
    "ğ‘" : "\u209A",
    "ğ‘Ÿ" : "áµ£",
    "ğ‘†" : "\u209B",
    "ğ‘ " : "\u209B",
    "ğ‘¡" : "\u209C",
    "ğ‘¢" : "áµ¤",
    "ğ‘‰" : "áµ¥",
    "ğ‘£" : "áµ¥",
    "ğ‘‹" : "\u2093",
    "ğ‘¥" : "\u2093",

    "ğ›½" : "\u1D66",
    "Î²" : "\u1D66",
    "ğ›¾" : "\u1D67",
    "Î³" : "\u1D67",
    "ğœŒ" : "\u1D68",
    "Ï" : "\u1D68",
    "ğœ‘" : "\u1D69",
    "Ï†" : "\u1D69",
    "ğœ™" : "\u1D69",
    "Ï•" : "\u1D69",
    "ğœ’" : "\u1D6A",
    "Ï‡" : "\u1D6A",

    "â†’" : spacesChar.add+spacesChar.add+"\u0362"+spacesChar.add+spacesChar.add,
    "âˆ" : spacesChar.add+"\u035A"+spacesChar.add,

    "\u2710" : spacesChar.add,
    "\u270E" : spacesChar.remove,
    " " : " ",
    "\u000A" : "\u000A",
    "" : ""
};

// Dict with characters and their corresponding symbol that can be combined and put above another symbol
const Above = {
    "." : "\u0307",
    ":" : "\u0308",
    "\u2236" : "\u0308",
    "-" : "\u0305",
    "âˆ’" : "\u0305",
    "`" : "\u0300",
    "Â´" : "\u0301",
    "^" : "\u0302",
    "=" : "\u033F",
    "âˆ¼" : "\u0303",
    "âˆ" : "\u1AB2", // Only works on certain website/apps
    "âˆ˜" : "\u030A",
    "Â°" : "\u030A",
    "a" : "\u0363",
    "ğ‘" : "\u0363",
    "b" : "\u1DE8",
    "ğ‘" : "\u1DE8",
    "c" : "\u0368",
    "ğ‘" : "\u0368",
    "d" : "\u0369",
    "ğ‘‘" : "\u0369",
    "e" : "\u0364",
    "ğ‘’" : "\u0364",
    "f" : "\u1DEB",
    "ğ‘“" : "\u1DEB",
    "h" : "\u036A",
    "â„" : "\u036A",
    "i" : "\u0365",
    "ğ‘–" : "\u0365",
    "k" : "\u1DDC",  // Only works on certain website/apps
    "ğ‘˜" : "\u1DDC",
    "m" : "\u036B",
    "ğ‘š" : "\u036B",
    "N" : "\u1DE1",
    "ğ‘" : "\u1DE1",
    "n" : "\u1DE0",  // Only works on certain website/apps
    "ğ‘›" : "\u1DE0",
    "o" : "\u0366",
    "ğ‘œ" : "\u0366",
    "p" : "\u1DEE",
    "ğ‘" : "\u1DEE",
    "R" : "\u1DE2",
    "ğ‘…" : "\u1DE2",
    "r" : "\u036C",
    "ğ‘Ÿ" : "\u036C",
    "t" : "\u036D",
    "ğ‘¡" : "\u036D",
    "u" : "\u0367",
    "ğ‘¢" : "\u0367",
    "v" : "\u036E",
    "ğ‘£" : "\u036E",
    "x" : "\u036F",
    "ğ‘¥" : "\u036F",

    "ğ›¼" : "\u1DE7",
    "Î±" : "\u1DE7",
    "ğ›½" : "\u1DE9",
    "Î²" : "\u1DE9",

    "â†¼" : "\u20D0",
    "â‡€" : "\u20D1",
    "â†”" : "\u20E1",
    "â†¶" : "\u20D4",
    "â†·" : "\u20D5",
    "â†" : "\u20D6",
    "â†’" : "\u20D7",
    "â†“" : "\u1AB3",
    "âˆ´" : "\u1AB4",
    "â‹¯" : "\u20DB",
    "â€¦" : "\u20DB",
    " " : " ",
    "\u000A" : "\u000A",
    "" : ""
};

// Dict with characters and their corresponding symbol that can be combined and put below another symbol
const Below = {
    "." : "\u0323",
    ":" : "\u0324",
    "\u2236" : "\u0324",
    "-" : "\u0332",
    "âˆ’" : "\u0332",
    "=" : "\u0333",
    "m" : "\u1AC0",
    "ğ‘š" : "\u1AC0",
    "x" : "\u0353",
    "ğ‘¥" : "\u0353",
    "w" : "\u1ABF",
    "ğ‘¤" : "\u1ABF",
    "â†½" : "\u20ED",
    "â‡" : "\u20EC",
    "â†" : "\u20EE",
    "â†’" : "\u20EF",
    "â†”" : "\u034D",
    " " : " ",
    "\u000A" : "\u000A",
    "" : ""
};

// Regular dict used to convert characters that are not a command
// Automatically convert text into a mathematical font
const lettersMath = {
    "+" : "\u002B",
    "-" : "\u2212",
    "=" : "\u003D",
    "'" : "\u2032",
    '"' : "\u2033",
    "/" : "/",
    "\\" : "\\",
    "," : ",",
    "." : ".",
    "Â°" : "Â°",
    "|" : "|",
    "!" : "!",
    "?" : "?",
    "*" : "*",
    "@" : "@",
    "&" : "&",
    "(" : "(",
    ")" : ")",
    "{" : "{",
    "}" : "}",
    "[" : "[",
    "]" : "]",
    "<" : "<",
    ">" : ">",
    "%" : "%",
    "#" : "#",
    "~" : "~",
    "Â¬" : "Â¬",
    ":" : "\u2236",
    ";" : ";",
    "â€¦" : "â€¦",
    "0" : "0",
    "1" : "1",
    "2" : "2",
    "3" : "3",
    "4" : "4",
    "5" : "5",
    "6" : "6",
    "7" : "7",
    "8" : "8",
    "9" : "9",
    "A" : "\u{1D434}",
    "a" : "\u{1D44E}",
    "B" : "\u{1D435}",
    "b" : "\u{1D44F}",
    "C" : "\u{1D436}",
    "c" : "\u{1D450}",
    "D" : "\u{1D437}",
    "d" : "\u{1D451}",
    "E" : "\u{1D438}",
    "e" : "\u{1D452}",
    "F" : "\u{1D439}",
    "f" : "\u{1D453}",
    "G" : "\u{1D43A}",
    "g" : "\u{1D454}",
    "H" : "\u{1D43B}",
    "h" : "\u210E",
    "I" : "\u{1D43C}",
    "i" : "\u{1D456}",
    "J" : "\u{1D43D}",
    "j" : "\u{1D457}",
    "K" : "\u{1D43E}",
    "k" : "\u{1D458}",
    "L" : "\u{1D43F}",
    "l" : "\u{1D459}",
    "M" : "\u{1D440}",
    "m" : "\u{1D45A}",
    "N" : "\u{1D441}",
    "n" : "\u{1D45B}",
    "O" : "\u{1D442}",
    "o" : "\u{1D45C}",
    "P" : "\u{1D443}",
    "p" : "\u{1D45D}",
    "Q" : "\u{1D444}",
    "q" : "\u{1D45E}",
    "R" : "\u{1D445}",
    "r" : "\u{1D45F}",
    "S" : "\u{1D446}",
    "s" : "\u{1D460}",
    "T" : "\u{1D447}",
    "t" : "\u{1D461}",
    "U" : "\u{1D448}",
    "u" : "\u{1D462}",
    "V" : "\u{1D449}",
    "v" : "\u{1D463}",
    "W" : "\u{1D44A}",
    "w" : "\u{1D464}",
    "X" : "\u{1D44B}",
    "x" : "\u{1D465}",
    "Y" : "\u{1D44C}",
    "y" : "\u{1D466}",
    "Z" : "\u{1D44D}",
    "z" : "\u{1D467}",
    "\u2710" : spacesChar.add,
    " " : " ",
    "\u000A" : "",
    "" : ""
};

// Dict used to convert characters that are not a command if the keyword !chem is used as the fist word of the text input
const lettersNoFont = {
    "+" : "\u002B",
    "-" : "\u2212",
    "=" : "\u003D",
    "'" : "\u2032",
    '"' : "\u2033",
    "/" : "/",
    "\\" : "\\",
    "," : ",",
    "." : ".",
    "Â°" : "Â°",
    "|" : "|",
    "!" : "!",
    "?" : "?",
    "&" : "&",
    "(" : "(",
    ")" : ")",
    "{" : "{",
    "}" : "}",
    "[" : "[",
    "]" : "]",
    "<" : "<",
    ">" : ">",
    "%" : "%",
    "*" : "*",
    "@" : "@",
    "#" : "#",
    "~" : "~",
    "Â¬" : "Â¬",
    ":" : ":",  // Same as "\colon", use "\ratio" instead to get the same as without "!chem"
    ";" : ";",
    "â€¦" : "â€¦",
    "0" : "0",
    "1" : "1",
    "2" : "2",
    "3" : "3",
    "4" : "4",
    "5" : "5",
    "6" : "6",
    "7" : "7",
    "8" : "8",
    "9" : "9", 
    "A" : "A",
    "a" : "a",
    "B" : "B",
    "b" : "b",
    "C" : "C",
    "c" : "c",
    "D" : "D",
    "d" : "d",
    "E" : "E",
    "e" : "e",
    "F" : "F",
    "f" : "f",
    "G" : "G",
    "g" : "g",
    "H" : "H",
    "h" : "h",
    "I" : "I",
    "i" : "i",
    "J" : "J",
    "j" : "j",
    "K" : "K",
    "k" : "k",
    "L" : "L",
    "l" : "l",
    "M" : "M",
    "m" : "m",
    "N" : "N",
    "n" : "n",
    "O" : "O",
    "o" : "o",
    "P" : "P",
    "p" : "p",
    "Q" : "Q",
    "q" : "q",
    "R" : "R",
    "r" : "r",
    "S" : "S",
    "s" : "s",
    "T" : "T",
    "t" : "t",
    "U" : "U",
    "u" : "u",
    "V" : "V",
    "v" : "v",
    "W" : "W",
    "w" : "w",
    "X" : "X",
    "x" : "x",
    "Y" : "Y",
    "y" : "y",
    "Z" : "Z",
    "z" : "z",
    "\u2710" : " ",
    " " : " ",
    "\u000A" : "",
    "" : ""
};

const lettersOutMathMode = {
    "+" : "+",
    "-" : "-",
    "=" : "=",
    "'" : "'",
    '"' : '"',
    "/" : "/",
    "\\" : "\\",
    "," : ",",
    "." : ".",
    "Â°" : "Â°",
    "|" : "|",
    "!" : "!",
    "?" : "?",
    "&" : "&",
    "(" : "(",
    ")" : ")",
    "{" : "{",
    "}" : "}",
    "[" : "[",
    "]" : "]",
    "<" : "<",
    ">" : ">",
    "%" : "%",
    "*" : "*",
    "^" : "^",
    "_" : "_",
    "@" : "@",
    "#" : "#",
    "~" : "~",
    "Â¬" : "Â¬",
    ":" : ":",
    ";" : ";",
    "â€¦" : "â€¦",
    "0" : "0",
    "1" : "1",
    "2" : "2",
    "3" : "3",
    "4" : "4",
    "5" : "5",
    "6" : "6",
    "7" : "7",
    "8" : "8",
    "9" : "9", 
    "A" : "A",
    "a" : "a",
    "B" : "B",
    "b" : "b",
    "C" : "C",
    "c" : "c",
    "D" : "D",
    "d" : "d",
    "E" : "E",
    "e" : "e",
    "F" : "F",
    "f" : "f",
    "G" : "G",
    "g" : "g",
    "H" : "H",
    "h" : "h",
    "I" : "I",
    "i" : "i",
    "J" : "J",
    "j" : "j",
    "K" : "K",
    "k" : "k",
    "L" : "L",
    "l" : "l",
    "M" : "M",
    "m" : "m",
    "N" : "N",
    "n" : "n",
    "O" : "O",
    "o" : "o",
    "P" : "P",
    "p" : "p",
    "Q" : "Q",
    "q" : "q",
    "R" : "R",
    "r" : "r",
    "S" : "S",
    "s" : "s",
    "T" : "T",
    "t" : "t",
    "U" : "U",
    "u" : "u",
    "V" : "V",
    "v" : "v",
    "W" : "W",
    "w" : "w",
    "X" : "X",
    "x" : "x",
    "Y" : "Y",
    "y" : "y",
    "Z" : "Z",
    "z" : "z",
    "\u2710" : " ",
    " " : " ",
    "\u000A" : "",
    "" : ""
};

const accents = {
    "\u0300" : "\u0300",
    "\u0301" : "\u0301",
    "\u0302" : "\u0302",
    "\u0303" : "\u0303",
    "\u0304" : "\u0304",
    "\u0305" : "\u0305",
    "\u0306" : "\u0306",
    "\u0307" : "\u0307",
    "\u0308" : "\u0308",
    "\u0309" : "\u0309",
    "\u030A" : "\u030A",
    "\u030B" : "\u030B",
    "\u030C" : "\u030C",
    "\u030D" : "\u030D",
    "\u030E" : "\u030E",
    "\u030F" : "\u030F",
    "\u0310" : "\u0310",
    "\u0311" : "\u0311",
    "\u0312" : "\u0312",
    "\u0313" : "\u0313",
    "\u0314" : "\u0314",
    "\u0315" : "\u0315",
    "\u0316" : "\u0316",
    "\u0317" : "\u0317",
    "\u0318" : "\u0318",
    "\u0319" : "\u0319",
    "\u031A" : "\u031A",
    "\u031B" : "\u031B",
    "\u031C" : "\u031C",
    "\u031D" : "\u031D",
    "\u031E" : "\u031E",
    "\u031F" : "\u031F",
    "\u0320" : "\u0320",
    "\u0321" : "\u0321",
    "\u0322" : "\u0322",
    "\u0323" : "\u0323",
    "\u0324" : "\u0324",
    "\u0325" : "\u0325",
    "\u0326" : "\u0326",
    "\u0327" : "\u0327",
    "\u0328" : "\u0328",
    "\u0329" : "\u0329",
    "\u032A" : "\u032A",
    "\u032B" : "\u032B",
    "\u032C" : "\u032C",
    "\u032D" : "\u032D",
    "\u032E" : "\u032E",
    "\u032F" : "\u032F",
    "\u0330" : "\u0330",
    "\u0331" : "\u0331",
    "\u0332" : "\u0332",
    "\u0333" : "\u0333",
    "\u0334" : "\u0334",
    "\u0335" : "\u0335",
    "\u0336" : "\u0336",
    "\u0337" : "\u0337",
    "\u0338" : "\u0338",
    "\u0339" : "\u0339",
    "\u033A" : "\u033A",
    "\u033B" : "\u033B",
    "\u033C" : "\u033C",
    "\u033D" : "\u033D",
    "\u033E" : "\u033E",
    "\u033F" : "\u033F",
    "\u0340" : "\u0340",
    "\u0341" : "\u0341",
    "\u0342" : "\u0342",
    "\u0343" : "\u0343",
    "\u0344" : "\u0344",
    "\u0345" : "\u0345",
    "\u0346" : "\u0346",
    "\u0347" : "\u0347",
    "\u0348" : "\u0348",
    "\u0349" : "\u0349",
    "\u034A" : "\u034A",
    "\u034B" : "\u034B",
    "\u034C" : "\u034C",
    "\u034D" : "\u034D",
    "\u034E" : "\u034E"
};


//-----------------------------------------------------//


/** HTMLElements **/

// Convert button
const convertButton = document.getElementById("convert");
convertButton.onclick = function() {main()};

// Copy button
const copyButton = document.getElementById("copy");
copyButton.onclick = function() {copyTextOut()};

// Clear button
const resetButton = document.getElementById("reset");
resetButton.onclick = function() {clear()};

// Button to open the completion popup
const completionBtn = document.getElementById("completionBtn");
completionBtn.onclick = function() {getCompletion()};
completionBtn.style.display = "inline-block";

// Originally hidden
// Can be accessed with a keyboard shortcut (Alt+C by default) or by clicking the button
const completionPopup = document.getElementById("completion");

// Adjust spaces button
const spacesButton = document.getElementById("adjust");

// Mathematical font button
const changeFontButton = document.getElementById("mathFont");

// Math mode button
const changeModeButton = document.getElementById("mathMode");

// First and second text box
const textIn = document.getElementById("text_in");
const textOut = document.getElementById("text_out");

const mistakesBox = document.getElementById("mistakes");


//-----------------------------------------------------//


/** Other **/

// Used in the subsection 'Completion box' to recognize on which word is the cursor
const wordsDelimiters = [" ", "", "\u000A", "\\", "^", "_", "(", ")", "[", "]", "{", "}", ".", ",", "/", "-", "+", "=", "<", ">", "|", "?", "!", "$"];
const wordsDelimitersWOB = [" ", "", "\u000A", "^", "_", "(", ")", "[", "]", "{", "}", ".", ",", "/", "-", "+", "=", "<", ">", "|", "?", "!", "$"]; // Without backslash

// Used in adjustSpacesCommon to chose which symbols to surround with spaces (if touched by a specific symbol like '+' or '-')
const characters = "AÃ€Ã‚BCÃ‡DEÃ‰ÃˆÃ‹ÃŠFGHIJKLMNOÃ”Ã–PQRSTUÃ™Ã›VWXYZaÃ Ã¢bcÃ§deÃ©Ã¨ÃªÃ«fghijklmnoÃ´Ã¶pqrstuÃ¹Ã»vwxyz0123456789"+
                   "ğ´ğµğ¶ğ·ğ¸ğ¹ğºğ»ğ¼ğ½ğ¾ğ¿ğ‘€ğ‘ğ‘‚ğ‘ƒğ‘„ğ‘…ğ‘†ğ‘‡ğ‘ˆğ‘‰ğ‘Šğ‘‹ğ‘Œğ‘ğ‘ğ‘ğ‘ğ‘‘ğ‘’ğ‘“ğ‘”â„ğ‘–ğ‘—ğ‘˜ğ‘™ğ‘šğ‘›ğ‘œğ‘ğ‘ğ‘Ÿğ‘ ğ‘¡ğ‘¢ğ‘£ğ‘¤ğ‘¥ğ‘¦ğ‘§"+
                   "ğ”¸ğ”¹â„‚ğ”»ğ”¼ğ”½ğ”¾â„ğ•€ğ•ğ•‚ğ•ƒğ•„â„•ğ•†â„™â„šâ„ğ•Šğ•‹ğ•Œğ•ğ•ğ•ğ•â„¤ğ•’ğ•“ğ•”ğ••ğ•–ğ•—ğ•˜ğ•™ğ•šğ•›ğ•œğ•ğ•ğ•Ÿğ• ğ•¡ğ•¢ğ•£ğ•¤ğ•¥ğ•¦ğ•§ğ•¨ğ•©ğ•ªğ•«ğŸ˜ğŸ™ğŸšğŸ›ğŸœğŸğŸğŸŸğŸ ğŸ¡"+
                   "ğ‘¨ğ‘©ğ‘ªğ‘«ğ‘¬ğ‘­ğ‘®ğ‘¯ğ‘°ğ‘±ğ‘²ğ‘³ğ‘´ğ‘µğ‘¶ğ‘·ğ‘¸ğ‘¹ğ‘ºğ‘»ğ‘¼ğ‘½ğ‘¾ğ‘¿ğ’€ğ’ğ’‚ğ’ƒğ’„ğ’…ğ’†ğ’‡ğ’ˆğ’‰ğ’Šğ’‹ğ’Œğ’ğ’ğ’ğ’ğ’‘ğ’’ğ’“ğ’”ğ’•ğ’–ğ’—ğ’˜ğ’™ğ’šğ’›"+
                   "ğ’œâ„¬ğ’ğ’Ÿâ„°â„±ğ’¢â„‹â„ğ’¥ğ’¦â„’â„³ğ’©ğ’ªğ’«ğ’¬â„›ğ’®ğ’¯ğ’°ğ’±ğ’²ğ’³ğ’´ğ’µğ’¶ğ’·ğ’¸ğ’¹â„¯ğ’»â„Šğ’½ğ’¾ğ’¿ğ“€ğ“ğ“‚ğ“ƒâ„´ğ“…ğ“†ğ“‡ğ“ˆğ“‰ğ“Šğ“‹ğ“Œğ“ğ“ğ“"+
                   "ğ”„ğ”…â„­ğ”‡ğ”ˆğ”‰ğ”Šâ„Œâ„‘ğ”ğ”ğ”ğ”ğ”‘ğ”’ğ”“ğ””â„œğ”–ğ”—ğ”˜ğ”™ğ”šğ”›ğ”œâ„¨ğ”ğ”Ÿğ” ğ”¡ğ”¢ğ”£ğ”¤ğ”¥ğ”¦ğ”§ğ”¨ğ”©ğ”ªğ”«ğ”¬ğ”­ğ”®ğ”¯ğ”°ğ”±ğ”²ğ”³ğ”´ğ”µğ”¶ğ”·"+
                   "ğ•¬ğ•­ğ•®ğ•¯ğ•°ğ•±ğ•²ğ•³ğ•´ğ•µğ•¶ğ•·ğ•¸ğ•¹ğ•ºğ•»ğ•¼ğ•½ğ•¾ğ•¿ğ–€ğ–ğ–‚ğ–ƒğ–„ğ–…ğ–†ğ–‡ğ–ˆğ–‰ğ–Šğ–‹ğ–Œğ–ğ–ğ–ğ–ğ–‘ğ–’ğ–“ğ–”ğ–•ğ––ğ–—ğ–˜ğ–™ğ–šğ–›ğ–œğ–ğ–ğ–Ÿ"+
                   "ğ“ğ“‘ğ“’ğ““ğ“”ğ“•ğ“–ğ“—ğ“˜ğ“™ğ“šğ“›ğ“œğ“ğ“ğ“Ÿğ“ ğ“¡ğ“¢ğ“£ğ“¤ğ“¥ğ“¦ğ“§ğ“¨ğ“©ğ“ªğ“«ğ“¬ğ“­ğ“®ğ“¯ğ“°ğ“±ğ“²ğ“³ğ“´ğ“µğ“¶ğ“·ğ“¸ğ“¹ğ“ºğ“»ğ“¼ğ“½ğ“¾ğ“¿ğ”€ğ”ğ”‚ğ”ƒ"+
                   "ğ—”ğ—•ğ—–ğ——ğ—˜ğ—™ğ—šğ—›ğ—œğ—ğ—ğ—Ÿğ— ğ—¡ğ—¢ğ—£ğ—¤ğ—¥ğ—¦ğ—§ğ—¨ğ—©ğ—ªğ—«ğ—¬ğ—­ğ—®ğ—¯ğ—°ğ—±ğ—²ğ—³ğ—´ğ—µğ—¶ğ—·ğ—¸ğ—¹ğ—ºğ—»ğ—¼ğ—½ğ—¾ğ—¿ğ˜€ğ˜ğ˜‚ğ˜ƒğ˜„ğ˜…ğ˜†ğ˜‡ğŸ¬ğŸ­ğŸ®ğŸ¯ğŸ°ğŸ±ğŸ²ğŸ³ğŸ´ğŸµ"+
                   "ğ˜ˆğ˜‰ğ˜Šğ˜‹ğ˜Œğ˜ğ˜ğ˜ğ˜ğ˜‘ğ˜’ğ˜“ğ˜”ğ˜•ğ˜–ğ˜—ğ˜˜ğ˜™ğ˜šğ˜›ğ˜œğ˜ğ˜ğ˜Ÿğ˜ ğ˜¡ğ˜¢ğ˜£ğ˜¤ğ˜¥ğ˜¦ğ˜§ğ˜¨ğ˜©ğ˜ªğ˜«ğ˜¬ğ˜­ğ˜®ğ˜¯ğ˜°ğ˜±ğ˜²ğ˜³ğ˜´ğ˜µğ˜¶ğ˜·ğ˜¸ğ˜¹ğ˜ºğ˜»"+
                   "ğ™°ğ™±ğ™²ğ™³ğ™´ğ™µğ™¶ğ™·ğ™¸ğ™¹ğ™ºğ™»ğ™¼ğ™½ğ™¾ğ™¿ğš€ğšğš‚ğšƒğš„ğš…ğš†ğš‡ğšˆğš‰ğšŠğš‹ğšŒğšğšğšğšğš‘ğš’ğš“ğš”ğš•ğš–ğš—ğš˜ğš™ğššğš›ğšœğšğšğšŸğš ğš¡ğš¢ğš£ğŸ¶ğŸ·ğŸ¸ğŸ¹ğŸºğŸ»ğŸ¼ğŸ½ğŸ¾ğŸ¿"+
                   "ğ˜¼ğ˜½ğ˜¾ğ˜¿ğ™€ğ™ğ™‚ğ™ƒğ™„ğ™…ğ™†ğ™‡ğ™ˆğ™‰ğ™Šğ™‹ğ™Œğ™ğ™ğ™ğ™ğ™‘ğ™’ğ™“ğ™”ğ™•ğ™–ğ™—ğ™˜ğ™™ğ™šğ™›ğ™œğ™ğ™ğ™Ÿğ™ ğ™¡ğ™¢ğ™£ğ™¤ğ™¥ğ™¦ğ™§ğ™¨ğ™©ğ™ªğ™«ğ™¬ğ™­ğ™®ğ™¯"+
                   "ğ›¢ğ›¼ğ›£ğ›½ğ›¤ğ›¾Î”ğ›¥ğ›¿ğ›¦ÏµÎµğ›§ğœğ›¨ğœ‚Î˜ğœƒğœ—ğ›ªğœ„ğ›«ğœ…ğœ˜ğ›¬ğœ†ğ›­ğœ‡ğ›®ğœˆÎ¦ğœ™ğœ‘Îğœ‰ğ›°ğœŠğ›±ğœ‹ğœ›ğ›²ğœŒÏ±ğ›´ğœğœğ›µğœğ›¶ğœğ›¸ğœ’ğ›¹ğœ“â„¦ğœ”"+
                   "ğœœğœ¶ğœğœ·ğœğœ¸ğš«ğœŸğœ¹ğœ ğ›œğ›†ğœ¡ğœ»ğœ¢ğœ¼ğš½ğœ½ğ‘ğœ¤ğœ¾ğœ¥ğœ¿ğ’ğœ¦ğ€ğœ§ğğœ¨ğ‚ğš½ğ“ğ‹ğšµğƒğœªğ„ğœ«ğ…ğ•ğœ¬ğ†ğ› ğœ®ğ›”ğ‡ğœ¯ğ‰ğœ°ğŠğœ²ğŒğœ³ğğ›€ğ"+ 
                   "Î‘Î±Î’Î²Î“Î³Î´Î–Î¶Î—Î·Î¸Ï‘Î™Î¹ÎšÎºÏ°Î›Î»ÎœÎ¼ÎÎ½Î¾ÎŸÎ¿Î Ï€Ï–Î¡ÏÏ±Î£ÏƒÏ‚Î¤Ï„Î¥Ï…Ï•Ï†Î§Ï‡Î¨ÏˆÎ©Ï‰" + 
                   "ğ–ğ°ğ—ğ±ğ˜ğ²ğ›…ğ›ğµğœğ¶ğ›‰ğ›ğğ›ŠğŸğ¹ğŒğ ğºğ¡ğ»ğ¢ğ¼ğ½ğ¤ğ¾ğ¥ğ¿ğğ¦ğ€ğğ¨ğ‚ğğ©ğƒğªğ„ğğ…ğ¬ğ†ğ­ğ‡ğ®ğˆ" +
                   "â„¾â„½â„¿â„¼â…€" + 
                   ")]}â¦†âŸ§â¦„";  // Only right parentheses, since the algorithm to adjust spaces only looks at the previous symbol

// Symbol for an error
const errSymbol = "\u{1D41E}\u0353\u{1D42B}\u0353\u{1D42B}";  // bold "err" with two "x" under it

// Every undefined commands
let errorsList = "";

// Recognize if the device is screen only
const touchScreen = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

// Used by tokenizer() and tokensToText()
const specialTokens = {startMathmode: "STARTMM", endMathmode: "ENDMM", startArgument: "STARTARG", endArgument: "ENDARG"};


/**************************************************************************************/


/// FUNCTIONS ///

/** Front-end **/

function copyTextOut() {
    // Copy second box (output) to clipboard
    if (textOut.disabled === false) {
        navigator.clipboard.writeText(textOut.value);
        copyButton.value = "Copied!";
        setTimeout(() => {
            copyButton.value = "Copy text";
        }, 2500)  // Returns to initial copyButton
    };
};

function copyTextIn() {
    // Copy first box (input) to clipboard
    navigator.clipboard.writeText(textIn.value);
};

function clear() {
    // Clears everything
    copyButton.value = "Copy text";
    mistakesBox.textContent = "";
    textOut.disabled = true;
    completionPopup.style.display = "none";
    completionPopup.textContent = "";
};

window.addEventListener("click", (event) => {
    // Closes the suggestion popup if the users clicks anywhere except on the suggestion popup itself or input box
    if (completionPopup.style.display === "inline-block") {
        if ((event.target.id !== "text_in") && (event.target.id !== "completionBtn")) {
            closeCompletion();
        };
    };
});

document.addEventListener("keydown", (keyPressed) => {
    // If any key is pressed while the completion popup is opened, it adjusts the suggestions
    // The word must be adjusted "by hand" because the eventListener is synchronous
    if (completionPopup.style.display === "inline-block") {
        if (keyPressed.key === "Backspace") {
            completionPopup.textContent = "";
            let word = findWord(textIn.value, textIn.selectionEnd - 1, "Backspace");
            completion(word);
        } else if (keyPressed.code === "Space") {
            closeCompletion();
        } else if (keyPressed.key.length === 1) {  // i.e. A letter
            completionPopup.textContent = "";
            let word = findWord(textIn.value, textIn.selectionEnd - 1, keyPressed.key);
            completion(word);
        } else if ((keyPressed.key === "ArrowUp") || (keyPressed.key === "ArrowRight") || (keyPressed.key === "ArrowLeft") || (keyPressed.key === "ArrowDown")) {
            completionPopup.textContent = "";
            const arrows = {"ArrowUp": 0, "ArrowRight": 1, "ArrowLeft": -1, "ArrowDown": 0};
            let word = findWord(textIn.value, (textIn.selectionEnd - 1 + arrows[keyPressed.key]));  // Only adjusts the cursor position for right and left arrows
            completion(word);
        };
    };
});


//-----------------------------------------------------//


/** Completion box **/

function closeCompletion() {
    // Close and empties the completion popup
    completionPopup.style.display = "none";
    completionPopup.textContent = "";
};

function getCompletion() {
    // Calls completion() with the word touching the cursor if the popup is closed, else it closes the popup
    if (completionPopup.style.display !== "inline-block") { 
        completionPopup.textContent = "";
        let word = findWord(textIn.value, textIn.selectionEnd - 1);
        completionPopup.style.display = "inline-block";
        completion(word);
    } else {
        closeCompletion();
    };
};

function findWord(text, cursorPosition, addedLetter="") {
    // Used in the completion popup
    // Finds the word that is touched by the cursor
    if (addedLetter.length === 1) {  // ie a letter
        text = text.split("");
        text[cursorPosition] += addedLetter;
        text = text.join("");
    } else if (addedLetter === "Backspace") {
        text = text.split("");
        text[cursorPosition] = "";
        text = text.join("");
        cursorPosition -= 1;
    };
    let word = "";
    while (!(wordsDelimiters.includes(text.charAt(cursorPosition + 1)))) {
        cursorPosition += 1;
    };
    while (!(wordsDelimitersWOB.includes(text.charAt(cursorPosition)))) {
        if (text.charAt(cursorPosition) === "\\") {
            word = text.charAt(cursorPosition) + word;
            break;
        } else {
            word = text.charAt(cursorPosition) + word;
            cursorPosition -= 1;
        }
    };
    return word;
};

function completion(command) {
    // Outputs list of other commands that are similar to the one currently being written
    const btnBackColor = mainColors["completion"]["backgroundTrTd"][(darkMode.checked) ? 1 : 0];
    const btnFontColor = (darkMode.checked) ? "whitesmoke" : "black";
    if (command === "") {
        closeCompletion();
    } else if (command[0] !== "\\") {
        let row = completionPopup.insertRow(-1);
        let cell = row.insertCell(0);
        cell.textContent = "The first character of the command must be a backslash (\\). Superscript starts with ^ and subscript with _";
        cell.style.color = btnFontColor;
    } else {
        command = command.substring(1, command.length);  // Erases the backslash so that, for instance, \arrow will also show \rightarrow, etc.
        for (let keys in defaultDict) {
            // Puts commands in button form, so they can be clicked on to replace the command being written
            if (keys.toLowerCase().indexOf(command.toLowerCase()) !== -1) {
                let row = completionPopup.insertRow(-1);
                let cell = row.insertCell(0);
                let btn = document.createElement("button");
                btn.name = showCommand(keys);
                btn.textContent = toReplaceCommand(keys);
                btn.value = toReplaceCommand(keys);  // Value is unchanged

                // Button style
                btn.style.width = "145px";  // Would be cleaner with something like 'fit-content', but is way to slow
                btn.style.height = "17px";
                btn.style.backgroundColor = btnBackColor
                btn.style.border = "1px solid " + btnBackColor;
                btn.style.color = btnFontColor;
                btn.style.borderRadius = "3px";
                btn.type = "button";
                btn.tabIndex = "0";

                cell.style.border = "1px solid " + btnBackColor;
                cell.style.backgroundColor = btnBackColor;

                // Complete the command if the user clicks on that command
                btn.addEventListener("click", () => {
                    textIn.value = semiAutoCompletion(textIn.value, textIn.selectionEnd, btn.value);
                    closeCompletion();
                    textIn.focus();
                });

                // Shows what the command ouputs on mouseover, return to normal on mouseout
                btn.addEventListener("mouseover", () => {
                    let tmp = btn.textContent;
                    btn.textContent = btn.name;
                    btn.name = tmp;
                });
                btn.addEventListener("mouseout", () => {
                    let tmp = btn.textContent;
                    btn.textContent = btn.name;
                    btn.name = tmp;
                });
                cell.appendChild(btn);
            };
        };
    };
};

function semiAutoCompletion(textIn, cursorPosition, command) {
    // Replace the command being written by the selected suggestion
    let textOut = textIn;
    // Find end of word
    while (!(wordsDelimiters.includes(textIn.charAt(cursorPosition)))) {
        cursorPosition += 1;
    };
    // Deletes word
    while (textIn.charAt(cursorPosition - 1) !== "\\") {
        textOut = textOut.substring(0, cursorPosition - 1) + textOut.substring(cursorPosition);
        cursorPosition -= 1;
    };
    // Replace by selected suggestion
    textOut = textOut.substring(0, cursorPosition - 1) + command + textOut.substring(cursorPosition);
    return textOut;
};

function showCommand(key) {
    // Used in completion
    // Changes what's seen when the user hovers on a command in the completion popup
    if (typeof defaultDict[key] == "function") {
        if (key == "\\sqrt") {
            return "\\sqrt[n]{x} \u2192 â¿âˆšğ‘¥";
        } else if (key == "\\frac") {
            return "\\frac{1}{2} \u2192 Â¹âˆ•â‚‚";
        } else if (key == "\\frac*") {
            return "\\frac*{1}{2} \u2192 Â½";
        } else if ((key == "\\overset") || (key == "\\underset") || (key == "\\stackrel") || (key == "\\hspace") || (key == "\\vskip")) {
            return key + "{}";
        } else if ((key == "_") || (key == "^")) {
            return "x" + key + "{a1} \u2192 ğ‘¥" + spaceCommand((defaultDict[key]([["a", "1"]], key)).join(""));
        } else if (key == "\\pmod") {
            return key + "{n} \u2192 " + spaceCommand(defaultDict[key]([["n"]], key).join(""));
        } else if (key == "\\matrix") {
            return key + "{[a,b]} \u2192 " + spaceCommand(defaultDict[key](["[a,b]".split("")], key).join(""));
        } else {
            return key + "{abc} \u2192 " + spaceCommand((defaultDict[key]([["a", "b", "c"]], key)).join(""));
        };
    } else {
        if (key == "\\:") {
            return "1 space";
        } else if ((key == "\\;") || ((key == "\\quad") || (key == "\\qquad"))) {
            return defaultDict[key].length + " spaces";
        } else if (key === "\\!") {
            return "Remove a space";
        } else if ((key == "\\id2") || (key == "\\id3") || (key == "\\id4") || (key == "\\idn")) {
            const M = {
                "\\id2": "â¡ 1 0 â¤\u000Aâ£ 0 1 â¦",
                "\\id3" : "â¡ 1 0 0 â¤\u000Aâ¢ 0 1 0 â¥\u000Aâ£ 0 0 1 â¦",
                "\\id4" : "â¡ 1 0 0 0 â¤\u000Aâ¢ 0 1 0 0 â¥\u000Aâ¢ 0 0 1 0 â¥\u000Aâ£ 0 0 0 1 â¦",
                "\\idn" : "â¡ 1 0 â‹¯ 0 â¤\u000Aâ¢ 0 1 â‹¯ 0 â¥\u000Aâ¢  â‹®  â‹®  â‹±  â‹® â¥\u000Aâ£ 0 0 â‹¯ 1 â¦"
            }
            return M[key];
        } else {
            return spaceCommand(defaultDict[key]);
        };
    };
};

function toReplaceCommand(key) {
    // Used in completion
    // Changes what the user sees when the completion popup is opened
    if (typeof defaultDict[key] == "function") {
        if (key == "\\sqrt") {
            return "\\sqrt[]{}";
        } else if (key == "\\frac") {
            return "\\frac{}{}";
        } else if (key == "\\frac*") {
            return "\\frac*{}{}";
        } else {
            return key + "{}";
        };
    } else {
        return key
    };
};


//-----------------------------------------------------//


/** Convert text **/


// Main functions

function tokenize(fullText, mathmode) {
    // This function takes the text as entered by the user, and outputs a list of tokens
    // For instance "curl written as $\nabla \times \mathbf{F}$" will output
    //  [c,u,r,l, ,w,r,i,t,t,e,n, ,a,s, ,STARTMM,\nabla, ,\times, ,\mathbf,STARTARG,F,ENDARG,ENDMM]
    const brackets = ["[", "]"];
    const commandStoppers = [" ", "\u000A", ",", "/", "-", "+", "<", ">", "|", "?", "(", ")"]; 
    // N.B. Brackets also stops commands (most of the time)
    const potentialCommandStoppers = [":" , ";" , "~", ".", "!", "'", '"', "=", "%", "#"];
    const startMathmode = mathmode;
    let outTokens = [];
    let temporaryBox = [];      // Stores characters that are in command (e.g. \int -> ['\', 'i', 'n', 't'])
    let trigger = false;        // true if a command has begun (e.g. input: '\' -> true)
    let mathmodeStarter = "";   // e.g. if mathmode is started with $$, then "$$" will be mathmodeStarter
    let char, i;

    if (startMathmode) {
        outTokens.push(specialTokens.startMathmode);
    };

    for (i=0; i<fullText.length; i++) {
        if (trigger) {
            if (commandStoppers.includes(fullText[i])) {
                outTokens.push(temporaryBox.join(""));
                outTokens.push(fullText[i]);
                trigger = false;
                temporaryBox = [];
            } else if (potentialCommandStoppers.includes(fullText[i])) {
                if (fullText[i-1] === "\\") {
                    temporaryBox.push(fullText[i]);
                } else {
                    outTokens.push(temporaryBox.join(""));
                    outTokens.push(fullText[i]);
                    trigger = false;
                    temporaryBox = [];
                };
            } else if (brackets.includes(fullText[i])) {
                if (fullText[i-1] === "\\") {
                    if (mathmode) {
                        if ((fullText[i] === "]") && (mathmodeStarter === "\\[")) {
                            mathmode = false;
                            mathmodeStarter = "";
                            outTokens.push("\\\\");
                            outTokens.push(specialTokens.endMathmode);
                        } else {
                            outTokens.push(temporaryBox.join("") + fullText[i]);
                        };
                    } else {
                        if (fullText[i] === "[") {
                            mathmode = true;
                            mathmodeStarter = "\\[";
                            outTokens.push("\\\\");
                            outTokens.push(specialTokens.startMathmode);
                        } else {
                            outTokens.push(temporaryBox.join("") + fullText[i]);
                        };
                    };
                    trigger = false;
                    temporaryBox = [];
                } else {
                    if (temporaryBox.slice(0,5).join("") === "\\sqrt") {
                        temporaryBox.push(fullText[i]);
                    } else {
                        outTokens.push(temporaryBox.join(""));
                        outTokens.push(fullText[i]);
                        trigger = false;
                        temporaryBox = [];
                    };
                };
            } else if (fullText[i] === "{") {
                if (fullText[i-1] === "\\") {
                    outTokens.push(temporaryBox.join("") + fullText[i]);
                } else {
                    outTokens.push(temporaryBox.join(""));
                    outTokens.push(specialTokens.startArgument);
                };
                trigger = false;
                temporaryBox = [];
            } else if (fullText[i] === "}") {
                if (fullText[i-1] === "\\") {
                    outTokens.push(temporaryBox.join("") + fullText[i]);
                } else {
                    outTokens.push(temporaryBox.join(""));
                    outTokens.push(specialTokens.endArgument);
                };
                trigger = false;
                temporaryBox = [];
            } else if (fullText[i] === "$") {
                if (fullText[i-1] === "\\") {
                    outTokens.push(temporaryBox.join("") + fullText[i]);
                } else {
                    if (mathmode) {
                        if (mathmodeStarter === "$") {
                            if (fullText[i-1] === "$") {
                                mathmodeStarter = "$$";
                                outTokens.push("\\\\");
                            } else {
                                mathmode = false;
                                mathmodeStarter = "";
                                outTokens.push(temporaryBox.join(""));
                                outTokens.push(specialTokens.endMathmode);
                            };
                        } else if ((fullText[i-1] === "$") && (mathmodeStarter === "$$")) {
                            mathmode = false;
                            mathmodeStarter = "";
                            outTokens.push("\\\\");
                            outTokens.push(specialTokens.endMathmode);
                        } else if (fullText[i+1] === "$") {
                            outTokens.push(temporaryBox.join(""));
                            continue;
                        } else {
                            outTokens.push(temporaryBox.join(""));
                            outTokens.push(fullText[i]);
                        };
                    } else {
                        mathmode = true;
                        mathmodeStarter = "$";
                        outTokens.push(temporaryBox.join(""));
                        outTokens.push(specialTokens.startMathmode);
                    };
                };
                trigger = false;
                temporaryBox = [];
            } else if (fullText[i] === "\\") {
                if (fullText[i-1] === "\\") {
                    outTokens.push(temporaryBox.join("") + fullText[i]);
                    trigger = false;
                    temporaryBox = [];
                } else {
                    outTokens.push(temporaryBox.join(""));
                    temporaryBox = [fullText[i]];
                };
            } else if ((fullText[i] === "^") || (fullText[i] === "_")) {
                if (fullText[i-1] === "\\") {
                    if (mathmode) {
                        outTokens.push(temporaryBox.join("") + fullText[i]);
                        trigger = false;
                        temporaryBox = [];
                    } else {
                        temporaryBox.push(fullText[i]);
                    };
                } else {
                    outTokens.push(temporaryBox.join(""));
                    temporaryBox = [fullText[i]];
                };
            } else {
                temporaryBox.push(fullText[i]);
            };
        } else {
            if (fullText[i] === "\\") {
                trigger = true;
                temporaryBox.push(fullText[i]);
            } else if ((fullText[i] === "^") || (fullText[i] === "_")) {
                if (mathmode) {
                    trigger = true;
                    temporaryBox.push(fullText[i]);
                } else {
                    outTokens.push(fullText[i]);
                };
            } else if (fullText[i] === "$") {
                if (mathmode) {
                    if (mathmodeStarter === "$") {
                        if (fullText[i-1] === "$") {
                            mathmodeStarter = "$$";
                            outTokens.push("\\\\");
                        } else if (fullText[i+1] === "$") {
                            continue;
                        } else {
                            mathmode = false;
                            mathmodeStarter = "";
                            outTokens.push(specialTokens.endMathmode);
                        };
                    } else if (mathmodeStarter === "$$") {
                        if (fullText[i-1] === "$") {
                            mathmode = false;
                            mathmodeStarter = "";
                            outTokens.push("\\\\");
                            outTokens.push(specialTokens.endMathmode);
                        };
                    }Â else {
                        outTokens.push(fullText[i]);
                    };
                } else {
                    mathmode = true;
                    mathmodeStarter = "$";
                    outTokens.push(specialTokens.startMathmode);
                };
            } else if (fullText[i] === "}") {
                outTokens.push(specialTokens.endArgument);
            } else if (fullText[i] === "{") {
                outTokens.push(specialTokens.startArgument);
            } else {
                char = fullText[i].normalize("NFD").split("");
                outTokens.push(...char);
            };
        };
    };

    if (startMathmode) {
        outTokens.push(specialTokens.endMathmode);
    };
    return outTokens;
};

function tokensToText(tokens, dictMM, dictOut, adjustSpacing, callSpaceCommand=true) {
    // Takes a list of tokens as input and uses the dictonary to convert them to symbols
    
    // The basic idea of the algorithm is:
    // Loop on tokens
    //     If token is STARTARG
    //         push to argStack
    //     If token is ENDARG
    //         pop from fctStack and argStack
    //         add the corresponding symbol to outText or mathmodeText
    //     Else
    //         push token to outText, mathmodeText, fctStack or the last index of argStack depending on token

    // E.g. If the input is: \f0{args0\f1{args1}}
    // Then at first, fctStack = [f0, f1] and argStack = [[args0], [args1]]
    // and then fctStack = [f0] and argStack = [[args0\f1{args1}]].

    let command;                 // Used to check if a command is a function or a symbol
    let fct;
    let fctStack = [];           // Stores the functions until they are used
    let callingFct;              // Might be different from fct (e.g. \\sqrt[3] is called with \\sqrt)
    let arg = [];
    let argStack = [];           // Stores the function arguments until they are used
    let outText = "";            // The text that will be returned
    let mathmodeText = "";       // Intermediary string that holds the text inside mathmode until the spaces are ajusted
    let mathmode = false;        // true if in mathmode, false if not
    let dict;                    // dictMM (mathmode) or dictOut (out of mathmode) depending if in mathmode or not
    let mathmodeOccurence = 0;   // Counts the number of times one enters and leaves mathmode
    let argDepth = 0;            // Add +1 if startArgument and -1 if endArgument
    let currentArgCount = [];    // Number of arguments per function
    let argNum;                  // Stores the number of arguments for the current function
    let i, j;

    for (i=0; i<tokens.length; i++) {
        dict = (mathmode) ? dictMM : dictOut;
        if (Object.values(specialTokens).includes(tokens[i])) {
            if (tokens[i] === specialTokens.startArgument) {
                argStack.push([]);
                argDepth += 1;
                if (tokens[i-1] !== specialTokens.endArgument) {
                    currentArgCount.push(1);
                };
            } else if (tokens[i] === specialTokens.endArgument) {
                argDepth -= 1;
                if (tokens[i+1] === specialTokens.startArgument) {
                    currentArgCount[currentArgCount.length-1] += 1;
                } else {
                    if (fctStack.length > 0) {
                        if (fctStack.length < currentArgCount.length) {
                            fct = "\\mathord";
                        } else {
                            fct = fctStack.pop();
                        };
                        if (argStack.length > 0) {
                            argNum = currentArgCount.pop();
                            for (j=0; j<argNum; j++) {
                                arg.unshift(argStack.pop());
                            };
                            if (fct.substring(0,5) === "\\sqrt") {
                                callingFct = fct.replace(/\[.*\]/g, "")
                            } else {
                                callingFct = fct;
                            };
                            if (argStack.length > 0) {
                                argStack[argStack.length-1].push(...dict[callingFct](arg, fct));
                            } else {
                                if (mathmode) {
                                    mathmodeText += str(dict[callingFct](arg, fct).join(""));
                                } else {
                                    outText += str(dict[callingFct](arg, fct).join(""));
                                };
                                mistakes(fct, dict[callingFct]);
                            };
                        } else {
                            if (mathmode) {
                                mathmodeText += mistakes(fct+"{}", undefined, "Can't find an argument");
                            } else {
                                outText += mistakes("Out of math mode", undefined, "Can't find an argument for " + fct + "{}");
                            };
                        };
                        arg = [];
                    } else {
                        currentArgCount = [];
                        while (argStack.length > 0) {
                            arg.unshift(argStack.pop());
                        };
                        if (mathmode) {
                            mathmodeText += str(mathord(arg, "").join(""));
                            mistakes("{"+arg.join("")+"}", mathord(arg, "").join(""), arg.join(""));
                        } else {
                            outText += mistakes("Out of math mode", undefined, "Can't find a function for {" + arg.join("") + "}" + ". Use '\\{' or '\\}' to output a curly bracket");
                        };
                        arg = [];
                    };
                };
            } else if (tokens[i] === specialTokens.startMathmode) {
                mathmodeOccurence += 1;
                mathmode = true;
            } else if (tokens[i] === specialTokens.endMathmode) {
                mathmodeOccurence += 1;
                mathmode = false;
                outText += adjustSpacing(mathmodeText);
                mathmodeText = "";
            };
        } else {
            if (tokens[i].substring(0,5) === "\\sqrt") {
                command = dict[tokens[i].replace(/\[.*\]/g, "")];
            } else {
                command = dict[tokens[i]];
            };
            if (typeof command == "function") {
                if (tokens[i+1] === specialTokens.startArgument) {
                    fctStack.push(tokens[i]);
                } else if (tokens.slice(i+1).filter(x => x !== " ")[0] === specialTokens.startArgument) {
                    if (mathmode) {
                        mathmodeText += mistakes(tokens[i]+" {}", undefined, "Remove extra spaces");
                    } else {
                        outText += mistakes("Out of math mode: "+tokens[i]+" {}", undefined, "Remove extra spaces");
                    };
                } else {
                    if (mathmode) {
                        if (command === sqrt) {
                            if (argStack.length > 0) {
                                argStack[argStack.length-1].push(...sqrt([], tokens[i]));
                            } else {
                                if (mathmode) {
                                    mathmodeText += str(sqrt([], tokens[i]).join(""));
                                    mistakes(tokens[i], sqrt([], tokens[i]).join(""));
                                } else {
                                    outText += str(sqrt([], tokens[i]).join(""));
                                    mistakes("Out of math mode", sqrt([], tokens[i]), tokens[i]);
                                };
                            };
                        } else {
                            mathmodeText += mistakes(tokens[i]+"{}", undefined, "Can't find an argument");
                        };
                    } else {
                        outText += mistakes("Out of math mode", undefined, "Can't find an argument for "+tokens[i]+"{}");
                    };
                };
            } else {
                if (argStack.length > 0) {
                    argStack[argStack.length-1].push(str(dict[tokens[i]]));
                    mistakes(tokens[i], dict[tokens[i]]);
                } else {
                    if (mathmode) {
                        mathmodeText += str(dict[tokens[i]]);
                        mistakes(tokens[i], dict[tokens[i]]);
                    } else {
                        outText += str(dict[tokens[i]]);
                        mistakes("Out of math mode", dict[tokens[i]], tokens[i]);
                    };
                };
            };
        };
    };
    if (mathmodeOccurence % 2 !== 0) {
        mistakes("Math mode was not closed", undefined);
    };
    if (argDepth > 0) {
        mistakes("Unbalanced curly brackets ('{', '}')", undefined, "Too many '{'");
    } else if (argDepth < 0) {
        mistakes("Unbalanced curly brackets ('{', '}')", undefined, "Too many '}'");
    };
    return (callSpaceCommand) ? spaceCommand(outText) : outText;
};


// Used by main functions

function replaceLetters(letters, dict, initialCommand, checkMistakes=true) {
    // Used by a lot of functions to convert every letter in a string of characters
    dict = {...dict, ...accents};
    let newtext = [];
    for (let c in letters) {
        newtext.push(addSymbol(dict[letters[c]]));
        if (checkMistakes) {
            mistakes(initialCommand + "{" + letters.join("") + "}", dict[letters[c]], (letters[c] !== errSymbol) ? letters[c] : "A symbol does not exist or can't be shown");
        };
    };
    return newtext;
};

function combineSymbols(arg, initialCommand, symbol, forTwo=undefined) {
    // Appends a 'combining symbol' to a regular symbol to create a new one (e.g. 'e' + 'Â´' -> Ã©)
    let textComb = [];
    let combArg = arg[0];
    if ((combArg.length === 2) && (forTwo !== undefined)) {
        textComb.push(str(combArg[0]) + forTwo + str(combArg[1]));
        mistakes(initialCommand + "{" + errSymbol + str(combArg[1]) + "}", combArg[0], "Argument doesn't exist");
        mistakes(initialCommand + "{" + str(combArg[0]) + errSymbol + "}", combArg[1], "Argument doesn't exist");
    } else {
        let err = [];
        for (let c in combArg) {
            if (combArg[c] !== undefined) {
                textComb.push(combArg[c] + symbol);
                err.push(combArg[c]);
            } else {
                textComb.push(errSymbol);
                err.push(errSymbol);
            };
        };
        if (err.includes(errSymbol)) {
            mistakes(initialCommand + "{" + err.join("") + "}", undefined, "Argument doesn't exist");
        };
    };
    return textComb.concat(extraArgs(arg.slice(1), initialCommand));
};

function addSymbol(command, keepArray=false) {
    // Return the command if it's defined, if not it returns a bold "err" with two "x" under it
    if ((typeof command == "object") && !(keepArray)) {
        // Changes an array of characters into a string
        command = command.join("");
    };
    return (command !== undefined) ? command : errSymbol;
};

function addSymbolArray(args, command, checkMistakes=true) {
    // Differs from the function above as it takes in an array instead of a string
    let output = [];
    for (let i in args) {
        output.push((args[i] !== undefined) ? args[i] : errSymbol);
        if (checkMistakes) {
            mistakes(command, ((args[i] === errSymbol) ||Â (args[i] === undefined)) ? undefined : args[i], "A symbol does not exist or can't be shown");
        };
    };
    return output.join("");
};

function str(command) {
    // Make sure the command is a string
    return (typeof command === "string") ? command : errSymbol;
};

function extraArgs(args, initialCommand) {
    // If the user enters to many arguments in a function, the extras will be sent to this function
    // e.g. \mathbf{A}{B} will result in \mathbf{A}\mathord{B}
    return mathord(args, initialCommand);
};


//-----------------------------------------------------//

/** Check mistakes **/

function mistakes(textInput, textOutput, letter="") {
    // Writes every errors in a box, so it's easier for the user to find them

    const text = "\u{1D404}\u{1D42B}\u{1D42B}\u{1D428}\u{1D42B}\u{1D42C}: \r\n";  // "Errors" in bold
    if (textOutput === undefined) {
        if (letter !== "") {
            if (letter !== errSymbol) {  // Only add to errorsList once
                if (letter.includes(spacesChar.add)) {
                    if (textInput.substring(0,5) === "\\text") {
                        errorsList += spaceCommand(textInput + " \u2192 Spaces are kept inside '" + textInput.replace(/{.*}/g, "") + "{}', no need for a spacing command") + "\r\n";
                    } else if ((textInput[0] === "^") || (textInput[0] === "_") || (textInput.substring(0,5) == "\\frac")) {
                        const initialSpaceCommand = ["\\:", "\\;", "\\quad", "\\qquad"];
                        errorsList += spaceCommand(textInput + " \u2192 Replace '" + initialSpaceCommand[letter.length-1] + "' by '\\hspace{" + letter.length + "}'") + "\r\n";
                    } else {
                        errorsList += spaceCommand(textInput + " \u2192 " + '"' + letter + '" \r\n');
                    };
                } else if ((textInput[0] === "^") || (textInput[0] === "_")) {
                    if (letter.indexOf("Can't find an argument") !== -1) {
                        const example = (textInput[0] === "^") ? "â¿" : "â‚™";
                        errorsList += "For '" + textInput[0] + "' alone: \\" + textInput[0] + " \u2192 " + textInput[0] + 
                        "  |  To use '" + textInput[0] + "' as a command: " + textInput[0] + "{n} \u2192 " + example + "\r\n";
                    } else {
                        errorsList += spaceCommand(textInput + " \u2192 " + '"' + letter + '" \r\n');
                    };
                } else {
                    errorsList += spaceCommand(textInput + " \u2192 " + '"' + letter + '" \r\n');
                };
            };
        } else {
            if ((textInput[0] === "^") || (textInput[0] === "_")) {
                if (textInput[1] === "{") {
                    errorsList += '"' + textInput + '" \u2192 ' + "Argument does not exists" + '\r\n';
                } else {
                    errorsList += '"' + textInput + '" \u2192 ' + "try: " + textInput[0] + "{" + textInput.slice(1) + "}" + '\r\n';
                };
            } else {
                errorsList += '"' + textInput + '" \r\n';
            };
        };
    };
    if (errorsList.length > 0) {
        mistakesBox.textContent = text + errorsList;
    };
    return [errSymbol];
};


//-----------------------------------------------------//

/** Matrix function **/

function matrix(text, initialCommand) {
    // Converts arrays into a matrix (i.e. \matrix{[a,b,c][1,2,3]} will be converted to the corresponding 2x3 matrix)
    text = text[0].join("")
                  .replace(/ /g, "");
    let matrixText = "";
    let i, x;
    let cpt = 0;
    let rceil = 0;
    let lceil = 0;
    let lfloor = 0;
    let rfloor = 0;

    for (x in text) {
        if (text[x] == "[" || text[x] == "]") {
            cpt += 1;
        };
    };
    if (cpt == 2) {
        // vector (ie single line matrix)
        matrixText = text;
        matrixText = matrixText.replace(/\[/g, "["+spacesChar.add);
        matrixText = matrixText.replace(/\]/g, spacesChar.add+"]");
        matrixText = matrixText.replace(/,/g, spacesChar.add);
        return [matrixText];
    } else {
        matrixText += "\u000A";
        for (i in text) {
            if (text[i] == "[" && rceil == 0) {
                matrixText += "\u23A1"+spacesChar.add;
                rceil += 1;
            } else if (text[i] == "]" && lceil == 0) {
                matrixText += spacesChar.add+"\u23A4\u000A";
                lceil += 1;
            } else if (text[i] == "]") {
                matrixText += spacesChar.add+"\u23A5\u000A";
            } else if (text[i] == "[") {
                matrixText += "\u23A2"+spacesChar.add;
            } else {
                matrixText += text[i];
            };
        };
        for (let n = matrixText.length; n > 0; n--) {
            if (matrixText[n] == "\u23A5" && n > rfloor) {
                matrixText = matrixText.split("");
                matrixText[n] = "\u23A6";
                matrixText[n+1] = "";  // removes "\u000A" since it's the last line
                matrixText = matrixText.join("");
                rfloor = n;
            } else if (matrixText[n] == "\u23A2" && n > lfloor) {
                matrixText = matrixText.split("");
                matrixText[n] = "\u23A3";
                matrixText = matrixText.join("");
                lfloor = n;
            };
        };
    };
    matrixText = matrixCols(matrixText);  // Adjusts columns width
    matrixText = matrixText.replace(/,/g, spacesChar.add);  // Add spaces between characters
    matrixText += "\u000A";
    if ((cpt % 2 != 0) || (cpt == 0)) {
        matrixText = errSymbol;
        mistakes('Wrong arguments given" \r\n  Example: "\\matrix{[a,b,c][d,e,f][1,2,3]}', undefined);
    } else if (changeFontButton.checked) {
        mistakes(initialCommand+"{}", undefined, "Works better with 'Mathematical font' unchecked");
    };
    return [matrixText];
};

function matrixCols(matrix) {
    // Adjusts columns length for \matrix command
    // So, if the input is [100,10,1][0,0,0], the output should still be a 2x3 matrix with the elements aligned
    let positionLength = 0;
    let posLengths = [];
    let matrixPositions = [];
    let matrixPos = 0;
    let realPositions = [];
    for (let i in matrix) {
        if (matrix[i] == ",") {
            matrixPositions.push(matrixPos);
            matrixPos += 1;
            posLengths.push(positionLength);
            positionLength = 0;
            realPositions.push(i-1);
        } else if ((matrix[i] == "\u23A4") || (matrix[i] == "\u23A5") || (matrix[i] == "\u23A6")) {  // right bracket
            matrixPositions.push(matrixPos);
            matrixPos = 0;
            posLengths.push(positionLength);
            positionLength = 0;
            realPositions.push(i-2);
        } else if ((matrix[i] == "\u23A1") || (matrix[i] == "\u23A2") || (matrix[i] == "\u23A3") || (matrix[i] == " ") || (matrix[i] == "\u000A")) {  // left bracket and spaces
            continue;
        } else {
            positionLength += 1;
        };
    };
    // Add spaces to adjust columns length
    let spacesAdded = 1;
    for (let i in posLengths) {
        for (let n in matrixPositions) {
            if (matrixPositions[i] == matrixPositions[n]) {
                matrix = matrix.split("");
                while (posLengths[i] < posLengths[n]) {
                    matrix.splice(realPositions[i] + spacesAdded, 0, spacesChar.add);
                    posLengths[i] += 1;
                    spacesAdded += 1;
                };
                matrix = matrix.join("");
            };
        };
    };
    return matrix;
};


//-----------------------------------------------------//

/** Automatic spacing **/

function spaceCommand(text) {
    // Add spaces ("\:" command)
    // Internally, spaces that are kept even if 'Adjust spaces' is on are represented as \u2710
    // this function changes them back to spaces
    let sp = new RegExp(spacesChar.add, "g");
    let sr = new RegExp(spacesChar.remove, "g");
    let srr = new RegExp(spacesChar.remove+" ", "g");
    let srl = new RegExp(" "+spacesChar.remove, "g");
    text = text.replace(sp, " ")

    // Also, it removes a space around the command \! (and the command itself)
            .replace(srr, "")
            .replace(srl, "")
            .replace(sr, "");
    return text;
};

function adjustSpacesCommon(input, symbolSpaced, conditionalSpaces) {
    // Removes spaces and add some depending on surrounding symbols
    // Used if 'Adjust space' is on
    // TODO: Linebreaks should be like in LaTeX, i.e. a single "enter" does nothing but two adds a linebreak.
    /* 
        TODO: Spacing around symbols like '+' should depend of context
        For instance f(y+2) should return f(y+2), but 3xÂ²+4y should return 3xÂ² + 4y 
        Also, a_{i}-x should return a_{i} - x, but \sum_{i}-x should return \sum_{i}-x (as in \sum_{i}(-x) or -\sum_{i}x)
        Again, it should take the context in consideration
    */

    if ((spacesButton.checked == true) && (input.length > 2)) {
        const noSpaceSymbols = Object.values(Subscript).concat(Object.values(Above), Object.values(Below)).filter(x => {return x !== spacesChar.add;});
        // noSpaceSymbols is a list of all the symbols (subscript and combined symbol, without spaces) that delay a space to be added.
        // For instance, the spaces in 'x \equiv_{2} 0 \def x \equiv 0 (mod 2)' should be kept the same and therefore 'delay' the space
        // to be added from \equiv because of the subscript.
        const spacedChar = characters.concat(noSpaceSymbols, Object.values(Superscript));  // Add space around 'conditionalSpaces' if the previous symbol is in spacedChar
        let output = "";
        input = input.replace(/ /g, "");
        let delayedSpace = false;
        let spaceStored = [];
        for (let i in input) {
            delayedSpace = noSpaceSymbols.includes(input[parseInt(i)+1]);
            if (symbolSpaced.includes(input[i])) {
                if ((output[output.length - 1] !== " ") &&Â (output[output.length - 1] !== undefined)) {
                    if (delayedSpace) {
                        output += " " + input[i];
                        spaceStored.push(" ");
                    } else {
                        output += " " + input[i] + " ";
                    }
                } else {
                    if (delayedSpace) {
                        output += input[i];
                        spaceStored.push(" ");
                    } else {
                        output += input[i] + " ";
                    };
                };
            } else if (conditionalSpaces.includes(input[i])) {
                if ((output[output.length - 1] !== " ") &&Â (output[output.length - 1] !== undefined) && (spacedChar.includes(output[output.length - 1]))) {
                    if (delayedSpace) {
                        output += " " + input[i];
                    } else {
                        output += " " + input[i] + " ";
                    };
                } else {
                    output += input[i];
                };
            } else {
                if (delayedSpace) {
                    output += input[i];
                } else {
                    if (spaceStored.length >= 1) {
                        output += input[i] + " ";
                        spaceStored = [];
                    }
                    else {
                        output += input[i];
                    };
                };
            };
        };
        return spaceCommand(output);
    } else {
        return spaceCommand(input);
    };
};

function adjustSpaces(input) {
    // Calls adjustSpacesCommon with specific symbols where spaces around them should be added
    // TODO: Maybe they should all be conditionalSpaces?
    const symbolSpaced = ["\u003D", "\u003C", "\u003E", "\u21D2", "\u21D0", "\u21CD", "\u21CF", "\u21CE", "\u2192", "\u27F6", "\u2190", "\u27F5", 
                          "\u2194", "\u21AE", "\u219A", "\u219B", "\u27F8", "\u27F9", "\u27F9", "\u21D4", "\u27FA", "\u27FC", "\u21CC", "\u21CB", 
                          "\u21C0", "\u21C1", "\u21BC", "\u21BD", "\u219E", "\u21A0", "\u21C7", "\u21C9", "\u21F6", "\u21C6", "\u21C4", "\u21DA", 
                          "\u21DB", "\u21A2", "\u21A3", "\u21DC", "\u21DD", "\u21AD", "\u27FF", "\u21E0", "\u21E2", "\u2208", "\u2209", "\u220B",
                          "\u2282", "\u2284", "\u2286", "\u2288", "\u2283", "\u2285", "\u2287", "\u2289", "\u228F", "\u2290", "\u2291", "\u2292",
                          "\u22D0", "\u22D1", "\u2ABF", "\u2AC0", "\u27C3", "\u27C4", "\u2245", "\u2247", "\u221D", "\u2261", "\u2A67", "\u2263",
                          "\u2260", "\u226E", "\u226F", "\u2264", "\u2A7D", "\u2265", "\u2A7E", "\u2270", "\u2271", "\u2A87", "\u2268", "\u2A88",
                          "\u2269", "\u2A89", "\u2A8A", "\u22E6", "\u22E7", "\u226A", "\u22D8", "\u226B", "\u22D9", "\u227A", "\u227B", "\u2280",
                          "\u2281", "\u227C", "\u227D", "\u2AB5", "\u2AB6", "\u2AB9", "\u2ABA", "\u22E8", "\u22E9", "\u27C2", "\u2AEB", "\u2226",
                          "\u2AF4", "\u2AF5", "\u224D", "\u2227", "\u2228", "\u27CE", "\u27CF", "\u2971", "\u2972", "\u2974", "\u2250", "\u2A66",
                          "\u00D7", "\u22CA", "\u22C9", "\u225D", "\u2254", "\u2255"];
    const conditionalSpaces = ["\u002B", "\u2212", "\u00B1", "\u2213", "\u2248", "\u223C", "\u224C", "\u2241"];
    return adjustSpacesCommon(input, symbolSpaced, conditionalSpaces);
};

function adjustSpaceChem(input) {  // Deprecated
    // Calls adjustSpacesCommon with specific symbols where spaces around them should be added
    const symbolSpaced = ["\u21D2", "\u21D0", "\u21CD", "\u21CF", "\u21CE", "\u2192", "\u27F6", "\u2190", "\u27F5", "\u003C", "\u003E",
                          "\u2194", "\u21AE", "\u219A", "\u219B", "\u27F8", "\u27F9", "\u27F9", "\u21D4", "\u27FA", "\u27FC", "\u21CC", "\u21CB", 
                          "\u21C0", "\u21C1", "\u21BC", "\u21BD", "\u219E", "\u21A0", "\u21C7", "\u21C9", "\u21F6", "\u21C6", "\u21C4", "\u21DA", 
                          "\u21DB", "\u21A2", "\u21A3", "\u21DC", "\u21DD", "\u21AD", "\u27FF", "\u21E0", "\u21E2", "\u2208", "\u2209", "\u220B",
                          "\u2282", "\u2284", "\u2286", "\u2288", "\u2283", "\u2285", "\u2287", "\u2289", "\u228F", "\u2290", "\u2291", "\u2292",
                          "\u22D0", "\u22D1", "\u2ABF", "\u2AC0", "\u27C3", "\u27C4", "\u2245", "\u2247", "\u221D", "\u2A67", "\u2250", "\u2A66",
                          "\u2260", "\u226E", "\u226F", "\u2264", "\u2A7D", "\u2265", "\u2A7E", "\u2270", "\u2271", "\u2A87", "\u2268", "\u2A88",
                          "\u2269", "\u2A89", "\u2A8A", "\u22E6", "\u22E7", "\u226A", "\u22D8", "\u226B", "\u22D9", "\u227A", "\u227B", "\u2280",
                          "\u2281", "\u227C", "\u227D", "\u2AB5", "\u2AB6", "\u2AB9", "\u2ABA", "\u22E8", "\u22E9", "\u27C2", "\u2AEB", "\u2226", 
                          "\u2AF4", "\u2AF5", "\u224D", "\u2227", "\u2228", "\u27CE", "\u27CF", "\u2971", "\u2972", "\u2974", "\u00D7", "\u22CA",
                          "\u22C9", "\u225D", "\u2254", "\u2255"];
    const conditionalSpaces = ["\u002B", "\u00B1", "\u2213", "\u2248", "\u223C", "\u224C", "\u2241"];
    return adjustSpacesCommon(input, symbolSpaced, conditionalSpaces);
};


//-----------------------------------------------------//

/** Main **/

function convert(fullText) {
    // Takes text and convert it based on the documentclass (or package)
    const dictOutMathmode = {...lettersOutMathMode, ...accents, ...textCommands};
    const firstWord = fullText.split(" ")[0];
    let fullDict;
    if (firstWord === "!chem") {  // TODO: Should remove this option
        // Chemistry package, differs in the automatic conversion of letters and spacing adjustments
        fullDict = makeDict(firstWord);
        fullText = fullText.replace("!chem", "");
        fullText = tokensToText(tokenize(fullText, changeModeButton.checked), fullDict, dictOutMathmode, adjustSpaceChem);
    } else {
        // Default package
        fullDict = makeDict("default");
        fullText = tokensToText(tokenize(fullText, changeModeButton.checked), fullDict, dictOutMathmode, adjustSpaces);
    };
    return fullText;
};

function makeDict(documentClass) {
    // Returns the full dictionary (in mathmode) with all the commands, letters, etc. based on documentclass and font choice
    const greek = (changeFontButton.checked) ? stdGreek : noStyleGreek;
    let letters;  // lettersMath or lettersNoFont
    if (documentClass === "!chem") {
        letters = lettersNoFont;  // Works better to "draw" molecules with lewis notation
    } else {  // documentClass === "default"
        letters = (changeFontButton.checked) ? lettersMath : lettersNoFont;
    };
    return {...mathDictionary, ...greek, ...letters, ...accents};
};

function main() {
    // Takes the original text (input) and outputs the new one, with the converted symbols

    let fullText = textIn.value;
    
    mistakesBox.textContent = "";  // Starts with an empty box for errors
    errorsList = "";  // Makes sure it starts empty

    fullText = convert(fullText + " ");

    textOut.value = fullText;
    textOut.disabled = false;
};